//@author: a0122357l



	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Command.h
	 */

#pragma once
#include <string>

using namespace std;
class Command
{
public:
	Command();
	~Command();
	virtual string execute()=0;
	virtual Command* getInverseCommand()=0;
};


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Command.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandAdd.cpp
	 */


/*
This class contains code that can execute the command "Add",
which adds a new Task into the application

When a task is added, it will be autosorted based on its attributes

This class is part of the Command Pattern through abstraction of
the implementation of the Command from the person that uses it,
in the Controller class
*/

#include "CommandAdd.h"


/*
* ====================================================================
*  Main Program
* ====================================================================
*/

//This method will create a new task object, with the attributes given 
//from the Parser and CommandBuilder classes. 
//It will then give feedback to the user accordingly
//
//@return feedback to user
string CommandAdd::execute(){

	TaskManager instance = *TaskManager::getInstance();

	Task taskToAdd = Task(_taskDetails, _taskStartTime,
		_taskEndTime, _taskDeadline, _taskPriority);

	instance.addTask(taskToAdd);

	return MESSAGE_ADDED;
}


//This method will create the Command to undo this add command
//
//@return Command* that undoes the current command
Command* CommandAdd::getInverseCommand(){

	TaskManager* taskManagerInstance = TaskManager::getInstance();

	//getting index to delete
	Task taskToAdd = Task(_taskDetails, _taskStartTime,
		_taskEndTime, _taskDeadline, _taskPriority);

	int indexToDelete = TaskManager::getIndexToInsert(taskToAdd);

	return new CommandDelete(indexToDelete + 1);
}


/*
* ====================================================================
*  Constructors
* ====================================================================
*/

//Default constuctor for creating a new Command Add
CommandAdd::CommandAdd(string taskDetails,
	Date *taskStartTime,
	Date *taskEndTime,
	Date *taskDeadline,
	Task::Priority taskPriority){
	_taskDetails = taskDetails;
	_taskStartTime = taskStartTime;
	_taskEndTime = taskEndTime;
	_taskDeadline = taskDeadline;
	_taskPriority = taskPriority;
}


/*
* ====================================================================
*  Variables and Messages Declaration
* ====================================================================
*/

const string CommandAdd::MESSAGE_ADDED = "Task has been added!";

	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandAdd.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandAdd.h
	 */


#pragma once
#include <string>
#include "Command.h"
#include "Date.h"
#include "Task.h"
#include "TaskManager.h"
#include <vector>
#include "CommandDelete.h"

using namespace std;
class CommandAdd : public Command
{
public:

	CommandAdd(string taskDetails,
		Date *taskStartTime,
		Date *taskEndTime,
		Date *taskDeadline,
		Task::Priority taskPriority);

	virtual string execute();

	virtual Command* getInverseCommand();

	static const string CommandAdd::MESSAGE_ADDED;

private:
	string _taskDetails;
	Date *_taskStartTime;
	Date *_taskEndTime;
	Date *_taskDeadline;
	Task::Priority _taskPriority;
};


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandAdd.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandBuilder.cpp
	 */


/*
This class contains code that creates the new Command object

This class creates the Command object by calling upon the Parser
to parse the attributes to the Command object, then creating the
Command object based on these attributes
*/

#include "CommandBuilder.h"


/*
* ====================================================================
*  Main Program
* ====================================================================
*/

//This operation creates the new Command* by calling the Parser to 
//parse the user input and using these attributes to create the Command
//
//@param the user input string
//@return the new Command* created
Command* CommandBuilder::parseCommand(string userInput){
	if (trim(userInput) == "") {
		return new CommandInvalid(userInput);
	}

	string commandTypeString = getFirstWord(userInput);

	CommandType commandType = determineCommandType(commandTypeString);

	Parser parser = Parser::Parser();

	switch (commandType){

	case CommandType::Add:{

		parser.parseCommandAdd(userInput);

		CommandBuilder::setAttributesFromParser(parser);

		return new CommandAdd(_taskDetails, _taskStartTime,
			_taskEndTime, _taskDeadline, _taskPriority);
	}

	case CommandType::Display:{
		return new CommandDisplay();
	}

	case CommandType::Update:{

		parser.parseCommandUpdate(userInput);

		CommandBuilder::setAttributesFromParser(parser);

		return new CommandUpdate(_taskDetails,
			_taskStartTime, _taskEndTime, _taskDeadline,
			_taskPriority, _taskNumber);
	}

	case CommandType::Delete:{

		parser.parseCommandDelete(userInput);

		CommandBuilder::setAttributesFromParser(parser);

		return new CommandDelete(_taskNumber);
	}

	case CommandType::Undo:

		return new CommandUndo();

	case CommandType::Mark:

		parser.parseCommandMark(userInput);

		CommandBuilder::setAttributesFromParser(parser);

		return new CommandMark(_taskNumber);

	case CommandType::Unmark:

		parser.parseCommandUnmark(userInput);

		CommandBuilder::setAttributesFromParser(parser);

		return new CommandUnmark(_taskNumber);

	case CommandType::Exit:

		return new CommandExit();

	case CommandType::Search:

		parser.parseCommandSearch(userInput);

		CommandBuilder::setAttributesFromParser(parser);

		return new CommandSearch(_taskDetails, _taskStartTime,
			_taskEndTime, _taskDeadline, _taskPriority,
			_duration, _taskMarked, _foundMarked, _foundPriority);

	case CommandType::ChangeFileLocation:

		parser.parseCommandChangeFileLocation(userInput);

		CommandBuilder::setAttributesFromParser(parser);

		return new CommandChangeFileLocation(_taskDetails);

	case CommandType::CheckFileLocation:

		return new CommandCheckFileLocation();

	default:
		return new CommandInvalid(userInput);
	}

}


/*
* ====================================================================
*  Second Level of Abstraction
* ====================================================================
*/

//This operation determines which of the supported command 
//types the user wants to perform
//
//@param the string that has the command type
//@return the command type
CommandBuilder::CommandType CommandBuilder::determineCommandType(
	string commandTypeString) {
	if (equalsIgnoreCase(commandTypeString, "add")) {
		return CommandType::Add;
	}
	else if (equalsIgnoreCase(commandTypeString, "display")) {
		return CommandType::Display;
	}
	else if (equalsIgnoreCase(commandTypeString, "update")) {
		return CommandType::Update;
	}
	else if (equalsIgnoreCase(commandTypeString, "delete")) {
		return CommandType::Delete;
	}
	else if (equalsIgnoreCase(commandTypeString, "exit")) {
		return CommandType::Exit;
	}
	else if (equalsIgnoreCase(commandTypeString, "undo")) {
		return CommandType::Undo;
	}
	else if (equalsIgnoreCase(commandTypeString, "mark")) {
		return CommandType::Mark;
	}
	else if (equalsIgnoreCase(commandTypeString, "unmark")) {
		return CommandType::Unmark;
	}
	else if (equalsIgnoreCase(commandTypeString, "search")) {
		return CommandType::Search;
	}
	else if (equalsIgnoreCase(commandTypeString, "checkfileloc")) {
		return CommandType::CheckFileLocation;
	}
	else if (equalsIgnoreCase(commandTypeString, "changefileloc")) {
		return CommandType::ChangeFileLocation;
	}
	else {
		return CommandType::Invalid;
	}
}


//This operation sets the attributes of CommandBuilder for the parser
//
//@param Parser object to set attribute from
void CommandBuilder::setAttributesFromParser(Parser parser){
	_taskDetails = parser.getTaskDetails();
	_taskStartTime = parser.getTaskStartTime();
	_taskEndTime = parser.getTaskEndTime();
	_taskDeadline = parser.getTaskDeadline();
	_taskPriority = parser.getTaskPriority();
	_duration = parser.getDuration();
	_taskMarked = parser.getTaskMarked();
	_taskNumber = parser.getTaskNumber();
	_foundMarked = parser.getFoundMarked();
	_foundPriority = parser.getFoundPriority();
}


/*
* ====================================================================
*  Constructor, Getters and Setters
* ====================================================================
*/

//Default constructor. Clears previous commands upon creating a new
//Command Builder
CommandBuilder::CommandBuilder(){
	clearPreviousCommand();
}

void CommandBuilder::clearPreviousCommand(){
	_taskDetails = "";
	_taskStartTime = NULL;
	_taskEndTime = NULL;
	_taskDeadline = NULL;
	_taskPriority = Task::NORMAL;
	_duration = "";
	_taskMarked = false;
	_taskNumber = -1;
	_foundMarked = false;
	_foundPriority = false;
}

string CommandBuilder::getTaskDetails(){
	return _taskDetails;
}

Date* CommandBuilder::getTaskStartTime(){
	return _taskStartTime;
}

Date* CommandBuilder::getTaskEndTime(){
	return _taskEndTime;
}

Date* CommandBuilder::getTaskDeadline(){
	return _taskDeadline;
}

Task::Priority CommandBuilder::getTaskPriority(){
	return _taskPriority;
}

string CommandBuilder::getDuration(){
	return _duration;
}

bool CommandBuilder::getTaskMarked(){
	return _taskMarked;
}

int CommandBuilder::getTaskNumber(){
	return _taskNumber;
}


/*
* ====================================================================
*  Additional functions
* ====================================================================
*/

string CommandBuilder::removeFirstWord(string userCommand) {
	return trim(replace(userCommand, getFirstWord(userCommand), ""));
}

string CommandBuilder::getFirstWord(string userCommand) {
	string commandTypeString = splitParameters(userCommand)[0];
	return commandTypeString;
}

// This method only split string based on delimiter space
vector<string> CommandBuilder::splitParameters(
	string commandParametersString){
	vector<string> tokens;
	istringstream iss(commandParametersString);
	copy(istream_iterator<string>(iss),
		istream_iterator<string>(),
		back_inserter<vector<string> >(tokens));

	return tokens;
}

inline string CommandBuilder::trim_right(
	const string& s, const string& delimiters) {
	return s.substr(0, s.find_last_not_of(delimiters) + 1);
}

inline string CommandBuilder::trim_left(
	const string& s, const string& delimiters) {
	return s.substr(s.find_first_not_of(delimiters));
}

inline string CommandBuilder::trim(
	const string& s, const string& delimiters) {
	if (!s.empty())
		return trim_left(trim_right(s, delimiters), delimiters);
	else
		return s;
}

bool CommandBuilder::equalsIgnoreCase(
	const string& str1, const string& str2) {
	if (str1.size() != str2.size()) {
		return false;
	}
	for (string::const_iterator c1 = str1.begin(),
		c2 = str2.begin(); c1 != str1.end(); ++c1, ++c2) {
		if (tolower(*c1) != tolower(*c2)) {
			return false;
		}
	}
	return true;
}

int CommandBuilder::parseInt(string str) {
	char c;
	int i = 0;
	std::stringstream ss(str);
	ss >> i;
	if (ss.fail() || ss.get(c)) {
		return INVALID_NUMBER_FORMAT;
	}
	else {
		return i;
	}
}

string CommandBuilder::replace(string a, string b, string c) {
	int pos;
	do {
		pos = a.find(b);
		if (pos != -1)  a.replace(pos, b.length(), c);
	} while (pos != -1);
	return a;
}


/*
* ====================================================================
*  Variables and Messages Declaration
* ====================================================================
*/

char CommandBuilder::buffer[255];
const string CommandBuilder::INVALID_MESSAGE_FORMAT = "Invalid command format: %s";
const string CommandBuilder::MESSAGE_PROGRAM_TERMINATION = "Press any key to terminate the program . . .";
const string CommandBuilder::ERROR_UNRECOGNISED_COMMAND_TYPE = "ERROR: Unrecognised command type";

	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandBuilder.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandBuilder.h
	 */


#pragma once
#include <string>
#include "Command.h"
#include "Task.h"
#include <vector>
#include <sstream>
#include "CommandAdd.h"
#include "CommandInvalid.h"
#include "CommandDisplay.h"
#include "Parser.h"
#include "CommandUpdate.h"
#include "CommandDelete.h"
#include "CommandExit.h"
#include "CommandUndo.h"
#include "CommandMark.h"
#include "CommandUnmark.h"
#include "CommandSearch.h"
#include "CommandChangeFileLocation.h"
#include "CommandCheckFileLocation.h"

using namespace std;

class CommandBuilder
{
public:

	enum CommandType {
		Add, Display, Update, Delete, Exit, Invalid, Undo, Mark, Unmark,
		Search, Sort, CheckFileLocation, ChangeFileLocation
	};

	CommandBuilder();

	void clearPreviousCommand();

	Command* parseCommand(string userInput);

	static CommandBuilder::CommandType determineCommandType(string commandTypeString);

	string getTaskDetails();
	Date* getTaskStartTime();
	Date* getTaskEndTime();
	Date* getTaskDeadline();
	Task::Priority getTaskPriority();
	string getDuration();
	bool getTaskMarked();
	int getTaskNumber();

	void setAttributesFromParser(Parser parser);


	//helper functions
	static string removeFirstWord(string userCommand);
	static string getFirstWord(string userCommand);
	static vector<string> splitParameters(string commandParametersString);
	static string trim_right(const string& s, const string& delimiters = " \f\n\r\t\v");
	static string trim_left(const string& s, const string& delimiters = " \f\n\r\t\v");
	static string trim(const string& s, const string& delimiters = " \f\n\r\t\v");
	static bool equalsIgnoreCase(const string& str1, const string& str2);
	static int parseInt(string str);
	static string replace(string a, string b, string c);

	static char buffer[255];
	static const string CommandBuilder::INVALID_MESSAGE_FORMAT;
	static const int INVALID_NUMBER_FORMAT = -1;
	static const string MESSAGE_PROGRAM_TERMINATION;
	static const string ERROR_UNRECOGNISED_COMMAND_TYPE;


private:
	int _taskNumber;
	string _taskDetails;
	Date *_taskStartTime;
	Date *_taskEndTime;
	Date *_taskDeadline;
	Task::Priority _taskPriority;
	string _duration;
	bool _taskMarked;
	bool _foundMarked;
	bool _foundPriority;
};


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandBuilder.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandDelete.cpp
	 */


/*
This class contains code that can execute the command "Delete",
which deletes a task by its displayed task number

This class is part of the Command Pattern through abstraction of
the implementation of the Command from the person that uses it,
in the Controller class
*/

#include "CommandDelete.h"


/*
* ====================================================================
*  Main Program
* ====================================================================
*/

//This method will delete a task which is accessed by its task number 
//It will then give feedback to the user accordingly
//
//@return feedback to user
string CommandDelete::execute(){

	// get the instance of the Task from task manager
	TaskManager instance = *TaskManager::getInstance();

	if (_taskNumber <= 0 || _taskNumber > instance.getNumberOfTasks()){

		throw CommandException(ERROR_MESSAGE_COMMAND_TASKNUM);

	}

	//get the task to edit, remove it from vector.
	Task currentTask = TaskManager::getTask(_taskNumber);

	TaskManager::removeTask(_taskNumber);

	sprintf_s(buffer, MESSAGE_DELETED.c_str(), _taskNumber);

	return buffer;
}


//This method will create the Command to undo this delete command
//
//@return Command* that undoes the current command
Command* CommandDelete::getInverseCommand(){

	TaskManager* taskManagerInstance = TaskManager::getInstance();

	if (_taskNumber <= 0 || _taskNumber >
		taskManagerInstance->getNumberOfTasks()){
		throw CommandException(ERROR_MESSAGE_COMMAND_TASKNUM);
	}

	//getting the task to add back 
	Task currentTask = TaskManager::getTask(_taskNumber);
	string taskDetails = currentTask.getTaskDetails();
	Date* taskStartTime = currentTask.getTaskStartTime();
	Date* taskEndTime = currentTask.getTaskEndTime();
	Date* taskDeadline = currentTask.getTaskDeadline();
	Task::Priority taskPriority = currentTask.getTaskPriority();

	return new CommandAdd(taskDetails, taskStartTime, taskEndTime, taskDeadline, taskPriority);
}


/*
* ====================================================================
*  Constructors
* ====================================================================
*/

//Default constructor for creating a new Command Delete
CommandDelete::CommandDelete(int taskNumber){

	_taskNumber = taskNumber;

}


/*
* ====================================================================
*  Variables and Messages Declaration
* ====================================================================
*/

const string CommandDelete::ERROR_MESSAGE_COMMAND_TASKNUM
= "Invalid task number!";
const string CommandDelete::MESSAGE_DELETED = "Deleted Task #%d";
char CommandDelete::buffer[255];


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandDelete.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandDelete.h
	 */

#pragma once
#include <string>
#include "Command.h"
#include "Date.h"
#include "Task.h"
#include "TaskManager.h"
#include <vector>
#include "CommandAdd.h"
#include "CommandException.h"

using namespace std;

class CommandDelete: public Command
{
public:

	CommandDelete(int taskNumber);

	virtual string execute();

	virtual Command* getInverseCommand();

	static const string CommandDelete::MESSAGE_DELETED;
	static char CommandDelete::buffer[255];
	static const string CommandDelete::ERROR_MESSAGE_COMMAND_TASKNUM;

private:
	int _taskNumber;
};


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandDelete.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandException.cpp
	 */


#include "CommandException.h"

CommandException::CommandException(std::string command){

	CommandException::command = command;
	message = ERROR_MESSAGE_COMMAND;
	errorCode = ERROR_CODE_COMMAND;

}

string CommandException::getMessage(){
	return message + getCommand();
}

string CommandException::getCommand(){
	return command;
}

const string CommandException::ERROR_MESSAGE_COMMAND = "Invalid Command: ";
const int CommandException::ERROR_CODE_COMMAND = 2;
	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandException.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandException.h
	 */

#pragma once
#include <string>
#include "CustomException.h"

using namespace std;

class CommandException : public CustomException
{

private:

	std::string command;

public:

	CommandException(std::string command);
	string getMessage();
	int getErrorCode();
	string getCommand();

	static const string CommandException::ERROR_MESSAGE_COMMAND;
	static const int CommandException::ERROR_CODE_COMMAND;

};

	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandException.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandExit.cpp
	 */


/*
This class contains code that can execute the command "Exit",
which exits the program

This class is part of the Command Pattern through abstraction of
the implementation of the Command from the person that uses it,
in the Controller class
*/

#include "CommandExit.h"


/*
* ====================================================================
*  Main Program
* ====================================================================
*/

//This method exits the program, with success
string CommandExit::execute(){

	exit(0);

	return "Exit with success!";

}


//No undo Command exists for the Command
Command* CommandExit::getInverseCommand(){

	return nullptr;

}


/*
* ====================================================================
*  Constructors
* ====================================================================
*/

CommandExit::CommandExit()
{
}


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandExit.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandExit.h
	 */

#pragma once
#include "Command.h"

class CommandExit: public Command
{
public:

	CommandExit();

	virtual string execute();

	virtual Command* getInverseCommand();

};


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandExit.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandInvalid.cpp
	 */


/*
This class contains code that can execute the command "Invalid",
which shows feedback to the user that the Command he entered is invalid

This class is part of the Command Pattern through abstraction of
the implementation of the Command from the person that uses it,
in the Controller class
*/

#include "CommandInvalid.h"


/*
* ====================================================================
*  Main Program
* ====================================================================
*/

//This method shows feedback to the user that the Command he entered
//was invalid
//
//@return feedback to user
string CommandInvalid::execute(){

	sprintf_s(buffer, INVALID_MESSAGE_FORMAT.c_str(), _userInput.c_str());

	return buffer;

}


//No undo Command exists for the Command
Command* CommandInvalid::getInverseCommand(){

	return nullptr;

}


/*
* ====================================================================
*  Constructors
* ====================================================================
*/

//Default constructor to create a new Command Invalid
CommandInvalid::CommandInvalid(string userInput){

	_userInput = userInput;

}


/*
* ====================================================================
*  Variables and Messages Declaration
* ====================================================================
*/

char CommandInvalid::buffer[255];
const string CommandInvalid::INVALID_MESSAGE_FORMAT
= "Invalid command format: %s";

	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandInvalid.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandInvalid.h
	 */

#pragma once
#include <string>
#include <vector>
#include "Command.h"

using namespace std;

class CommandInvalid : public Command
{
public:

	CommandInvalid(string userInput);

	virtual string execute();

	virtual Command* getInverseCommand();

	static char CommandInvalid::buffer[255];
	static const string CommandInvalid::INVALID_MESSAGE_FORMAT;

private:
	string _userInput;
};


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandInvalid.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandMark.cpp
	 */


/*
This class contains code that can execute the command "Mark",
which marks a task as done

When a task is marked as done, it will be shifted in TaskManager
to another task vector which contain all the marked tasks. This
is to support easy display to the UI

This class is part of the Command Pattern through abstraction of
the implementation of the Command from the person that uses it,
in the Controller class
*/

#include "CommandMark.h"


/*
* ====================================================================
*  Main Program
* ====================================================================
*/

//This method will mark a task as done 
//The task to be marked will be accessed by its task number 
//It will then give feedback to the user accordingly
//
//@return feedback to user
string CommandMark::execute(){

	TaskManager instance = *TaskManager::getInstance();

	//get the task to edit
	Task currentTask = TaskManager::getTask(_taskNumber);

	//only mark the task if not already marked
	if (currentTask.getTaskMarked() == true){

		sprintf_s(buffer, MESSAGE_NOT_MARKED.c_str(), _taskNumber);

		return buffer;

	}

	else{

		TaskManager::markTask(_taskNumber);

		sprintf_s(buffer, MESSAGE_MARKED.c_str(), _taskNumber);

		return buffer;
	}
}


//This method will create the Command to undo this mark command
//
//@return Command* that undoes the current command
Command* CommandMark::getInverseCommand(){

	TaskManager* taskManagerInstance = TaskManager::getInstance();

	if (_taskNumber <= 0 || _taskNumber > taskManagerInstance->getNumberOfTasks()){

		throw CommandException(ERROR_MESSAGE_COMMAND_TASKNUM);

	}

	Task currentTask = TaskManager::getTask(_taskNumber);

	//only has an inverse command if task not already marked
	if (!currentTask.getTaskMarked()){

		//preparing marked task to add
		Task currentTask = TaskManager::getTask(_taskNumber);
		string taskDetails = currentTask.getTaskDetails();
		Date* taskStartTime = currentTask.getTaskStartTime();
		Date* taskEndTime = currentTask.getTaskEndTime();
		Date* taskDeadline = currentTask.getTaskDeadline();
		Task::Priority taskPriority = currentTask.getTaskPriority();
		Task taskToAdd = Task(taskDetails, taskStartTime,
			taskEndTime, taskDeadline, taskPriority);
		taskToAdd.setTaskMarked(true);

		vector<Task> allCurr = *TaskManager::getAllCurrentTasks();
		//deleting unmarked task
		TaskManager::removeTask(_taskNumber);
		//allCurr = *TaskManager::getAllCurrentTasks();

		//getting index to add new updated task to
		int indexToUnmark = TaskManager::getIndexToInsert(taskToAdd);

		//adding back unmarked task
		taskToAdd.setTaskMarked(false);

		TaskManager::addTask(taskToAdd);

		return new CommandUnmark(indexToUnmark + 1);
	}

	else{

		return nullptr;

	}
}


/*
* ====================================================================
*  Constructors
* ====================================================================
*/

//Default constructor for creating a new Command Mark
//
//@param task number to mark
CommandMark::CommandMark(int taskNumber){

	_taskNumber = taskNumber;

}


/*
* ====================================================================
*  Variables and Messages Declaration
* ====================================================================
*/

const string CommandMark::ERROR_MESSAGE_COMMAND_TASKNUM = "Invalid task number!";
const string CommandMark::MESSAGE_MARKED = "Marked Task #%d";
const string CommandMark::MESSAGE_NOT_MARKED = "Task #%d is already marked!";
char CommandMark::buffer[255];
	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandMark.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandMark.h
	 */

#pragma once
#include <string>
#include "Command.h"
#include "Date.h"
#include "Task.h"
#include "TaskManager.h"
#include <vector>
#include "CommandUnmark.h"
#include "CommandException.h"

class CommandMark : public Command
{
public:

	CommandMark(int taskNumber);

	virtual string execute();

	virtual Command* getInverseCommand();

	static const string CommandMark::MESSAGE_MARKED;
	static const string CommandMark::MESSAGE_NOT_MARKED;
	static const string CommandMark::ERROR_MESSAGE_COMMAND_TASKNUM;
	static char CommandMark::buffer[255];

private:

	int _taskNumber;
};


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandMark.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandUndo.cpp
	 */


/*
This class contains code that can execute the command "Undo",
which undoes the previous Command that can be undone

This class is part of the Command Pattern through abstraction of
the implementation of the Command from the person that uses it,
in the Controller class
*/

#include "CommandUndo.h"


/*
* ====================================================================
*  Main Program
* ====================================================================
*/

//This method will undo the previous undoable command
//
//@return feedback to user
string CommandUndo::execute(){

	Controller* instance = Controller::getInstance();

	vector<Command*>* undoStack = instance->getUndoStack();

	if (undoStack->size() == 0){

		return MESSAGE_NOTHING_TO_UNDO;

	}

	else{

		Command* undoCommand = (*undoStack)[undoStack->size() - 1];

		undoStack->pop_back();

		undoCommand->execute();

		return MESSAGE_ACTION_UNDONE;

	}
}

//There is no Command to undo the undo command!
Command* CommandUndo::getInverseCommand(){

	return nullptr;

}


/*
* ====================================================================
*  Constructors
* ====================================================================
*/

//Default constructor for undo
CommandUndo::CommandUndo()
{
}


/*
* ====================================================================
*  Variables and Messages Declaration
* ====================================================================
*/

const string CommandUndo::MESSAGE_NOTHING_TO_UNDO = "There is nothing to undo!";
const string CommandUndo::MESSAGE_ACTION_UNDONE = "Action has been undone!";





	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandUndo.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandUndo.h
	 */

#pragma once
#include "Command.h"
#include "Controller.h"

class CommandUndo: public Command
{
public:

	CommandUndo();


	virtual string execute();
	virtual Command* getInverseCommand();

	static const string CommandUndo::MESSAGE_NOTHING_TO_UNDO;
	static const string CommandUndo::MESSAGE_ACTION_UNDONE;
};


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandUndo.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandUnmark.cpp
	 */


/*
This class contains code that can execute the command "Unmark",
which unmarks a done task

When a marked task is unmarked, it will be shifted in TaskManager
from a task vector containing all the marked tasks to a task
vector containing all the unmarked tasks
This is to support easy display to the UI

This class is part of the Command Pattern through abstraction of
the implementation of the Command from the person that uses it,
in the Controller class
*/

#include "CommandUnmark.h"


/*
* ====================================================================
*  Main Program
* ====================================================================
*/

//This method will unmark a done task
//The task to be unmarked will be accessed by its task number 
//It will then give feedback to the user accordingly
//
//@return feedback to user
string CommandUnmark::execute(){

	TaskManager instance = *TaskManager::getInstance();

	//get the task to edit
	Task currentTask = TaskManager::getTask(_taskNumber);

	//only mark the task if not already marked
	if (currentTask.getTaskMarked() == false){

		sprintf_s(buffer, MESSAGE_NOT_UNMARKED.c_str(), _taskNumber);

		return buffer;

	}

	else{

		TaskManager::unmarkTask(_taskNumber);

		sprintf_s(buffer, MESSAGE_UNMARKED.c_str(), _taskNumber);

		return buffer;
	}
}


//This method will create the Command to undo this unmark command
//
//@return Command* that undoes the current command
Command* CommandUnmark::getInverseCommand(){

	TaskManager* taskManagerInstance = TaskManager::getInstance();

	if (_taskNumber <= 0 || _taskNumber > taskManagerInstance->getNumberOfTasks()){

		throw CommandException(ERROR_MESSAGE_COMMAND_TASKNUM);

	}

	Task currentTask = TaskManager::getTask(_taskNumber);

	//only has an inverse command if task not already unmarked
	if (currentTask.getTaskMarked()){

		//preparing unmarked task to add
		Task currentTask = TaskManager::getTask(_taskNumber);
		string taskDetails = currentTask.getTaskDetails();
		Date* taskStartTime = currentTask.getTaskStartTime();
		Date* taskEndTime = currentTask.getTaskEndTime();
		Date* taskDeadline = currentTask.getTaskDeadline();
		Task::Priority taskPriority = currentTask.getTaskPriority();
		Task taskToAdd = Task(taskDetails, taskStartTime, taskEndTime, taskDeadline, taskPriority);

		//deleting marked task
		TaskManager::removeTask(_taskNumber);

		//getting index to add new updated task to
		int indexToMark = TaskManager::getIndexToInsert(taskToAdd);

		//adding back marked task
		taskToAdd.setTaskMarked(true);
		TaskManager::addTask(taskToAdd);

		return new CommandMark(indexToMark + 1);
	}

	else{

		return nullptr;

	}
}


/*
* ====================================================================
*  Constructors
* ====================================================================
*/

CommandUnmark::CommandUnmark(int taskNumber){

	_taskNumber = taskNumber;

}


/*
* ====================================================================
*  Variables and Messages Declaration
* ====================================================================
*/

const string CommandUnmark::MESSAGE_UNMARKED = "Unmarked Task #%d";
const string CommandUnmark::MESSAGE_NOT_UNMARKED = "Task #%d is already unmarked!";
const string CommandUnmark::ERROR_MESSAGE_COMMAND_TASKNUM = "Invalid task number!";
char CommandUnmark::buffer[255];

	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandUnmark.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandUnmark.h
	 */

#pragma once
#include <string>
#include "Command.h"
#include "Date.h"
#include "Task.h"
#include "TaskManager.h"
#include <vector>
#include "CommandMark.h"

class CommandUnmark : public Command
{
public:

	CommandUnmark(int taskNumber);

	virtual string execute();

	virtual Command* getInverseCommand();

	static const string CommandUnmark::MESSAGE_UNMARKED;
	static const string CommandUnmark::MESSAGE_NOT_UNMARKED;
	static const string CommandUnmark::ERROR_MESSAGE_COMMAND_TASKNUM;
	static char CommandUnmark::buffer[255];

private:
	int _taskNumber;
};


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandUnmark.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandUpdate.cpp
	 */


/*
This class contains code that can execute the command "Update",
which updates a task that has already been entered
This task will be accessed by the task number displayed on screen

When a task is updated, it will be auto sorted
internally based on its new attributes

This class is part of the Command Pattern through abstraction of
the implementation of the Command from the person that uses it,
in the Controller class
*/

#include "CommandUpdate.h"


/*
* ====================================================================
*  Main Program
* ====================================================================
*/

//This method will update a previously entered task, with attributes
//given from the Parser and CommandBuilder classes. 
//The task to update will be accessed by its task number
//It will then give feedback to the user accordingly
//
//@return feedback to user
string CommandUpdate::execute(){

	//get the instance of the Task from task manager
	TaskManager instance = *TaskManager::getInstance();

	if (_taskNumber <= 0 || _taskNumber > instance.getNumberOfTasks()){
		throw CommandException(ERROR_MESSAGE_COMMAND_TASKNUM);
	}

	//get the task to edit, remove it from vector.
	Task currentTask = TaskManager::getTask(_taskNumber);
	TaskManager::removeTask(_taskNumber);

	/*
	//editing task to add back to vector
	currentTask.setTaskDetails(_taskDetails);
	currentTask.setTaskStartTime(_taskStartTime);
	currentTask.setTaskEndTime(_taskEndTime);
	currentTask.setTaskDeadline(_taskDeadline);
	currentTask.setTaskPriority(_taskPriority);
	*/

	Task newTask = Task(_taskDetails, _taskStartTime, _taskEndTime,
		_taskDeadline, _taskPriority);

	//adding task back to vector (but at the back, not fixed)
	instance.addTask(newTask);

	sprintf_s(buffer, MESSAGE_UPDATED.c_str(), _taskNumber);

	return buffer;
}


//This method will create the Command to undo this update command
//
//@return Command* that undoes the current command
Command* CommandUpdate::getInverseCommand(){

	TaskManager* taskManagerInstance = TaskManager::getInstance();

	if (_taskNumber <= 0 || _taskNumber >
		taskManagerInstance->getNumberOfTasks()){

		throw CommandException(ERROR_MESSAGE_COMMAND_TASKNUM);

	}

	//preparing old task to update
	Task currentTask = TaskManager::getTask(_taskNumber);
	Task duplicateTask = currentTask.clone();
	string taskDetails = currentTask.getTaskDetails();
	Date* taskStartTime = currentTask.getTaskStartTime();
	Date* taskEndTime = currentTask.getTaskEndTime();
	Date* taskDeadline = currentTask.getTaskDeadline();
	Task::Priority taskPriority = currentTask.getTaskPriority();

	//preparing new task to add
	Task taskToAdd = Task(_taskDetails, _taskStartTime, _taskEndTime,
		_taskDeadline, _taskPriority);
	taskToAdd.setTaskMarked(currentTask.getTaskMarked());

	//deleting old task
	TaskManager::removeTask(_taskNumber);

	//getting index to add new updated task to
	int indexToUpdate = TaskManager::getIndexToInsert(taskToAdd);

	//adding back old task
	TaskManager::addTask(currentTask);

	//undoing task
	return new CommandUpdate(taskDetails, taskStartTime, taskEndTime,
		taskDeadline, taskPriority, indexToUpdate + 1);
}


/*
* ====================================================================
*  Constructors
* ====================================================================
*/

//Default constructor for creating a new command update
CommandUpdate::CommandUpdate(string taskDetails,
	Date *taskStartTime,
	Date *taskEndTime,
	Date *taskDeadline,
	Task::Priority taskPriority,
	int taskNumber){
	_taskDetails = taskDetails;
	_taskStartTime = taskStartTime;
	_taskEndTime = taskEndTime;
	_taskDeadline = taskDeadline;
	_taskPriority = taskPriority;
	_taskNumber = taskNumber;
}


/*
* ====================================================================
*  Variables and Messages Declaration
* ====================================================================
*/

const string CommandUpdate::ERROR_MESSAGE_COMMAND_TASKNUM
= "Invalid task number!";
const string CommandUpdate::MESSAGE_UPDATED = "Updated Task #%d!";
char CommandUpdate::buffer[255];

	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandUpdate.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandUpdate.h
	 */

#pragma once
#include <string>
#include "Command.h"
#include "Date.h"
#include "Task.h"
#include "TaskManager.h"
#include <vector>
#include "CommandException.h"

class CommandUpdate : public Command
{
public:

	CommandUpdate(string taskDetails,
		Date *taskStartTime,
		Date *taskEndTime,
		Date *taskDeadline,
		Task::Priority taskPriority,
		int taskNumber);

	virtual string execute();

	virtual Command* getInverseCommand();

	static const string CommandUpdate::MESSAGE_UPDATED;
	static char CommandUpdate::buffer[255];
	static const string CommandUpdate::ERROR_MESSAGE_COMMAND_TASKNUM;

private:
	string _taskDetails;
	Date *_taskStartTime;
	Date *_taskEndTime;
	Date *_taskDeadline;
	Task::Priority _taskPriority;
	int _taskNumber;
};


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CommandUpdate.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Controller.cpp
	 */


/*
This class is used to manage Taskky's logic flow to process the user input,
and execute the command parsed
It is also used to initialize the program.
It is a singleton class, so that there will only be 1 instance of the tasks

It also supports the passing of a vector<int> of found tasks when a user
searches for tasks, that indicated the indexes the tasks are found
*/

#include "Controller.h"


/*
* ====================================================================
*  Main Program
* ====================================================================
*/

//This operation is used to initialize the program by loading tasks
//from storage
void Controller::initializeComponent(){

	TaskManager::loadAllCurrentTasks(Storage::readFromFile());

}


//This operation processes the user input and executes the user input
//
//@param the user input string
//@return the feedback string to display to the user
string Controller::processUserInput(string userInput){

	ErrorLogger* errorLogger = ErrorLogger::getInstance();

	string feedback;

	_isSearchCommand = false;

	try{

		TaskManager* taskManager = TaskManager::getInstance();

		CommandBuilder commandBuilder = CommandBuilder();

		Command* command = commandBuilder.parseCommand(userInput);

		Command* undoCommand = command->getInverseCommand();

		if (undoCommand != nullptr){

			getUndoStack()->push_back(undoCommand);

		}

		feedback = command->execute();

		taskManager->saveTasks();

		CommandSearch* commandSearch = dynamic_cast<CommandSearch*>(command);

		if (commandSearch != NULL){

			setTaskIndices(commandSearch->getTasksIndices());

			_isSearchCommand = true;

		}

	}

	catch (ParseException& e){

		feedback = e.getMessage();

		errorLogger->logError(feedback);

	}

	catch (CommandException& e){

		feedback = e.getMessage();

		errorLogger->logError(feedback);

	}

	return feedback;
}


/*
* ====================================================================
*  Constructor, Getters and Setters
* ====================================================================
*/

void Controller::setTaskIndices(vector<int>* taskIndices){

	_taskIndices = taskIndices;

}


vector<int>* Controller::getTaskIndices(){

	return _taskIndices;

}

//returns the boolean containing information 
//if the current command is search
bool Controller::getIsSearchCommand(){

	return _isSearchCommand;

}


//The default constructor instantiates a new error logger
Controller::Controller(){

	ErrorLogger* errorLogger = ErrorLogger::getInstance();

}


//Ensures the singleton pattern is followed
Controller* Controller::getInstance(){

	if (!_instance)

		_instance = new Controller;

	return _instance;
}


vector<Command*>* Controller::getUndoStack(){

	if (!_undoStack)

		_undoStack = new vector<Command*>;

	return _undoStack;
}


/*
* ====================================================================
*  Variables and Messages Declaration
* ====================================================================
*/

// Global static pointer used to ensure a single instance of the class.
Controller* Controller::_instance = NULL;
vector<Command*>* Controller::_undoStack = NULL;
bool Controller::_isSearchCommand;

//Task indices are used to indicate the indexes of tasks found
//using the command Search
vector<int>* Controller::_taskIndices = NULL;

	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Controller.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Controller.h
	 */

#pragma once
#include <string>

#include "Command.h"
#include "CommandBuilder.h"
#include "TaskManager.h"
#include "Storage.h"
#include "SuggestionBuilder.h"
#include "ParseException.h"
#include "CommandException.h"
#include "ErrorLogger.h"

using namespace std;

class Controller
{
public:

	static Controller* getInstance();

	static vector<Command*>* getUndoStack();

	static string processUserInput(string userInput);

	static void initializeComponent();

	static void setTaskIndices(vector<int>* taskIndices);

	static vector<int>* getTaskIndices();

	static bool getIsSearchCommand();

private:

	//copy constructor is private
	Controller& operator=(Controller const&){};

	static Controller *_instance;

	static vector<Command*>* _undoStack;

	static vector<int>* _taskIndices;

	static bool _isSearchCommand;

	Controller();

};


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Controller.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CustomException.cpp
	 */


#include "CustomException.h"

CustomException::CustomException(){
	message = "Error!";
	errorCode = 0;
	fatal = false;
}

CustomException::CustomException(string message){
	CustomException::message = message;
	errorCode = 0;
	fatal = false;
}
string CustomException::getMessage() {
	return message;
}

int CustomException::getErrorCode() {
	return errorCode;
}

bool CustomException::isFatal() {
	return fatal;
}

	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CustomException.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CustomException.h
	 */

#pragma once
#include <string>

using namespace std;

class CustomException
{

protected:

	std::string message;
	int errorCode;
	bool fatal;

public:
	CustomException();
	CustomException(std::string message);
	std::string getMessage();
	int getErrorCode();
	bool isFatal();

};


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\CustomException.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Date.cpp
	 */


#include "Date.h"

//Default is construct current date
Date::Date(){
	std::chrono::system_clock::time_point today = std::chrono::system_clock::now();
	_currentDate = today;
}

Date::Date(int year, int mon, int day, int hour, int min){
	struct std::tm t;
	t.tm_sec = 0;        // second of minute (0 .. 59 and 60 for leap seconds)
	t.tm_min = min;        // minute of hour (0 .. 59)
	t.tm_hour = hour;      // hour of day (0 .. 23)
	t.tm_mday = day;       // day of month (0 .. 31)
	t.tm_mon = mon;      // month of year (0 .. 11)
	t.tm_year = year - 1900; // year since 1900
	t.tm_isdst = -1;       // determine whether daylight saving time
	std::time_t tt = std::mktime(&t);
	if (tt == -1) {
		throw "no valid system time";
	}
	_currentDate = std::chrono::system_clock::from_time_t(tt);
}


string Date::toString(){
	char buffer[255];

	std::time_t t = std::chrono::system_clock::to_time_t(_currentDate);
	//std::string ts = ctime(&t);   // convert to calendar time
	//ts.resize(ts.size() - 1);       // skip trailing newline
	//return ts;

	struct tm* ts = localtime(&t);
	strftime(buffer, 80, "%d %b %Y (%a), %I:%M%p", ts);
	return buffer;
}

string Date::parseDateToDisplay(){

	ostringstream dateToDisplay;

	dateToDisplay << "[" << getDay() << "/" << getMonth()
		<< "/" << getYear() << "] " << getDayName();

	return dateToDisplay.str();
}

	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Date.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Date.cpp
	 */

bool Date::sameDate(Date dateToCompare){
	if (getYear() == dateToCompare.getYear() &&
		getMonth() == dateToCompare.getMonth() &&
		getDay() == dateToCompare.getDay()){
		return true;
	}
	return false;
}

std::chrono::system_clock::time_point Date::getTimePoint(){
	return _currentDate;
}


//process difference between timepoints, looking at minute scale
//if earlier, return 1
//if same, return 0
//if later, return -1
int Date::isEarlierThan(Date dateToCompare){
	chrono::time_point<chrono::system_clock> tp;
	tp = dateToCompare.getTimePoint();
	std::chrono::minutes dateMinutes = std::chrono::duration_cast<std::chrono::minutes>(getTimePoint() - tp);
	std::chrono::minutes date2Minutes = std::chrono::duration_cast<std::chrono::minutes>(dateToCompare.getTimePoint() - tp);
	int numMinutes = date2Minutes.count() - dateMinutes.count();
	if (numMinutes == 0){
		return 0;
	}
	else if (numMinutes>0){
		return 1;
	}
	else{
		return -1;
	}
}

int Date::diffInMinutes(Date dateToCompare){
	chrono::time_point<chrono::system_clock> tp;
	tp = dateToCompare.getTimePoint();
	std::chrono::minutes dateMinutes = std::chrono::duration_cast<std::chrono::minutes>(getTimePoint() - tp);
	std::chrono::minutes date2Minutes = std::chrono::duration_cast<std::chrono::minutes>(dateToCompare.getTimePoint() - tp);
	int numMinutes = date2Minutes.count() - dateMinutes.count();
	return numMinutes;
}

int Date::getYear(){
	time_t tt = std::chrono::system_clock::to_time_t(getTimePoint());
	tm local_tm = *localtime(&tt);
	return local_tm.tm_year + 1900;
}

int Date::getMonth(){
	time_t tt = std::chrono::system_clock::to_time_t(getTimePoint());
	tm local_tm = *localtime(&tt);
	return local_tm.tm_mon;
}

int Date::getDay(){
	time_t tt = std::chrono::system_clock::to_time_t(getTimePoint());
	tm local_tm = *localtime(&tt);
	return local_tm.tm_mday;
}

int Date::getDayName(){
	time_t tt = std::chrono::system_clock::to_time_t(getTimePoint());
	tm local_tm = *localtime(&tt);
	return local_tm.tm_wday;
}

int Date::getHour(){
	time_t tt = std::chrono::system_clock::to_time_t(getTimePoint());
	tm local_tm = *localtime(&tt);
	return local_tm.tm_hour;
}

int Date::getMinute(){
	time_t tt = std::chrono::system_clock::to_time_t(getTimePoint());
	tm local_tm = *localtime(&tt);
	return local_tm.tm_min;
}

	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Date.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Date.cpp
	 */

int Date::parseInt(string str){
	char c;
	int i = 0;
	std::stringstream ss(str);
	ss >> i;
	if (ss.fail() || ss.get(c)){
		return INVALID_NUMBER_FORMAT;
	}
	else {
		return i;
	}
}

	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Date.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Date.cpp
	 */

int Date::parseMonthName(string monthName){
	int mon = 0;

	std::transform(monthName.begin(), monthName.end(), monthName.begin(), ::tolower);

	if (monthName == "january" || monthName == "jan"){
		mon = 0;
	}
	else if (monthName == "february" || monthName == "feb"){
		mon = 1;
	}
	else if (monthName == "march" || monthName == "mar"){
		mon = 2;
	}
	else if (monthName == "april" || monthName == "apr"){
		mon = 3;
	}
	else if (monthName == "may"){
		mon = 4;
	}
	else if (monthName == "june" || monthName == "jun"){
		mon = 5;
	}
	else if (monthName == "july" || monthName == "jul"){
		mon = 6;
	}
	else if (monthName == "august" || monthName == "aug"){
		mon = 7;
	}
	else if (monthName == "september" || monthName == "sep"){
		mon = 8;
	}
	else if (monthName == "october" || monthName == "oct"){
		mon = 9;
	}
	else if (monthName == "november" || monthName == "nov"){
		mon = 10;
	}
	else if (monthName == "december" || monthName == "dec"){
		mon = 11;
	} //else throw error

	return mon;
}
	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Date.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Date.h
	 */

#pragma once
#include <chrono>
#include <ctime>
#include <string>
#include <vector>
#include <iostream>
#include <sstream>
#include <algorithm>

using namespace std;

class Date
{
public:
	Date();
	Date(int year, int mon, int day, int hour, int min);
	
	int isEarlierThan(Date dateToCompare);
	int Date::diffInMinutes(Date dateToCompare);

	bool sameDate(Date dateToCompare);

	std::chrono::system_clock::time_point getTimePoint();

	string toString();
	string parseDateToDisplay();
	static Date *toDate(string date_str);

	int getYear();
	int getMonth();
	int getDay();
	int getDayName();
	int getHour();
	int getMinute();

private:
	std::chrono::system_clock::time_point _currentDate;
	//For toDate time-date Parsing
	static string removeFirstWord(string userCommand);
	static string getFirstWord(string userCommand);
	static vector<string> splitParameters(string commandParametersString);
	static string trim_right(const string& s, const string& delimiters = " \f\n\r\t\v");
	static string trim_left(const string& s, const string& delimiters = " \f\n\r\t\v");
	static string trim(const string& s, const string& delimiters = " \f\n\r\t\v");
	static bool equalsIgnoreCase(const string& str1, const string& str2);
	static int parseInt(string str);
	static string replace(string a, string b, string c);
	static int parseMonthName(string monthName);

	static char buffer[255];
	static const int INVALID_NUMBER_FORMAT = -1;

};


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Date.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\ErrorLogger.cpp
	 */


#include "ErrorLogger.h"

ErrorLogger* ErrorLogger::_instance = NULL;

ErrorLogger::ErrorLogger()
{
	resetLog();
}

ErrorLogger* ErrorLogger::getInstance(){
	if (!_instance)
		_instance = new ErrorLogger;
	return _instance;
}

//Gets the date so that it can be logged down
string ErrorLogger::getDate(){

	return Date().toString();

}

void ErrorLogger::resetLog(){

	ofstream errorLog(ERROR_TEXT_FILE.c_str());
	errorLog << ERROR_MESSAGE_RESET << getDate();
	errorLog << endl << endl;
	errorLog.close();

}

void ErrorLogger::logError(string error){

	ofstream errorLog(ERROR_TEXT_FILE.c_str(), fstream::app);
	errorLog << getDate();
	errorLog << ERROR_MESSAGE_DELIMITER << error << ERROR_MESSAGE_DELIMITER;
	errorLog << endl << endl;
	errorLog.close();

}

const string ErrorLogger::ERROR_TEXT_FILE = "ErrorLog.txt";
const string ErrorLogger::ERROR_MESSAGE_RESET = "Error Log Resetted on: ";
const string ErrorLogger::ERROR_MESSAGE_DELIMITER = " | ";
	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\ErrorLogger.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\ErrorLogger.h
	 */


#pragma once
#include <string>
#include "Date.h"
#include <fstream>

using namespace std;

class ErrorLogger
{
public:

	static const string ErrorLogger::ERROR_TEXT_FILE;
	static const string ErrorLogger::ERROR_MESSAGE_RESET;
	static const string ErrorLogger::ERROR_MESSAGE_DELIMITER;

	static ErrorLogger* getInstance();

	static string getDate();

	static void resetLog();

	static void logError(string error);


private:

	ErrorLogger();

	//copy constructor is private
	ErrorLogger& operator=(ErrorLogger const&){};

	static ErrorLogger *_instance;
};


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\ErrorLogger.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\ParseException.cpp
	 */


#include "ParseException.h"

ParseException::ParseException(std::string input){

	ParseException::input = input;
	message = ERROR_MESSAGE_PARSING;
	errorCode = ERROR_CODE_PARSING;

}

string ParseException::getMessage(){
	return message + getInput();
}

string ParseException::getInput(){
	return input;
}

const string ParseException::ERROR_MESSAGE_PARSING = "Input parsing error: ";
const int ParseException::ERROR_CODE_PARSING = 1;
	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\ParseException.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\ParseException.h
	 */

#pragma once
#include <string>
#include "CustomException.h"

using namespace std;

class ParseException : public CustomException
{

private:

	std::string input;

public:

	ParseException(std::string input);
	string getMessage();
	int getErrorCode();
	string getInput();

	static const string ParseException::ERROR_MESSAGE_PARSING;
	static const int ParseException::ERROR_CODE_PARSING;

};

	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\ParseException.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Parser.cpp
	 */

/*
* ====================================================================
*  Parser for Command Search
* ====================================================================
*/
void Parser::parseCommandSearch(string userCommand){

	string text = removeFirstWord(userCommand);
	toLowerCase(text);
	vector<string> textVec = splitParameters(text);
	textVec.push_back("\n");	//Represents the end of vector

	string timeString;
	ostringstream temp;
	vector<string>::iterator iter = textVec.begin();

	//Search using task details
	while (!isSearchKeyword(*iter)){
		temp << *iter << " ";
		iter++;
	};
	_taskDetails = temp.str();
	temp.str("");

	//Search using task start time 
	if (equalsIgnoreCase(*iter, "from")){
		iter++;
		while (!equalsIgnoreCase(*iter, "to")){
			temp << *iter << " ";
			iter++;

			if (iter == textVec.end()){
				throw CommandException(ERROR_MESSAGE_NOENDTIME);
			}
		};
		timeString = temp.str();
		_taskStartTime = parseTimeString(timeString);
		temp.str("");

		//Search using task end time
		iter++;
		while (!isSearchKeyword(*iter)){
			temp << *iter << " ";
			iter++;
		};
		timeString = temp.str();
		_taskEndTime = parseTimeString(timeString);
		temp.str("");
	}

	//Search for tasks before a certain date
	if (equalsIgnoreCase(*iter, "before")){
		iter++;
		while (!isSearchKeyword(*iter)){
			temp << *iter << " ";
			iter++;
		};
		timeString = temp.str();
		_taskEndTime = parseTimeString(timeString);
		temp.str("");
	}

	//Search for tasks after a certain date
	if (equalsIgnoreCase(*iter, "after")){
		iter++;
		while (!isSearchKeyword(*iter)){
			temp << *iter << " ";
			iter++;
		};
		timeString = temp.str();
		_taskStartTime = parseTimeString(timeString);
		temp.str("");
	}

	//Search for marked/unmarked tasks
	if (equalsIgnoreCase(*iter, "done")){
		_taskMarked = true;
		_foundMarked = true;
	} else if (equalsIgnoreCase(*iter, "undone")){
		_taskMarked = false;
		_foundMarked = true;
	}

	//Search using priority
	if (equalsIgnoreCase(*iter, "#impt") || equalsIgnoreCase(*iter, "#high")){
		_taskPriority = Task::Priority::HIGH;
		_foundPriority = true;
	} 

	//Search for next available timeslot
	if (equalsIgnoreCase(*iter, "next")){
		iter++;
		if (equalsIgnoreCase(*iter, "available")) {
			iter++;
		}
		while (!isSearchKeyword(*iter)){
			temp << *iter << " ";
			iter++;
		}
		_duration = temp.str();
	}
}

/*
* ====================================================================
*  Parser for Command Changefileloc
* ====================================================================
*/
void Parser::parseCommandChangeFileLocation(string userCommand){
	Parser::clearPreviousParse();

	string text = removeFirstWord(userCommand);
	_taskDetails = text;
}


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Parser.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\StringDistance.cpp
	 */


#include "StringDistance.h"

//****************************
// Get minimum of three values
//****************************

int StringDistance::Minimum(int a, int b, int c)
{
	int mi;

	mi = a;
	if (b < mi) {
		mi = b;
	}
	if (c < mi) {
		mi = c;
	}
	return mi;

}

//**************************************************
// Get a pointer to the specified cell of the matrix
//************************************************** 

int *StringDistance::GetCellPointer(int *pOrigin, int col, int row, int nCols)
{
	return pOrigin + col + (row * (nCols + 1));
}

//*****************************************************
// Get the contents of the specified cell in the matrix 
//*****************************************************

int StringDistance::GetAt(int *pOrigin, int col, int row, int nCols)
{
	int *pCell;

	pCell = GetCellPointer(pOrigin, col, row, nCols);
	return *pCell;

}

//*******************************************************
// Fill the specified cell in the matrix with the value x
//*******************************************************

void StringDistance::PutAt(int *pOrigin, int col, int row, int nCols, int x)
{
	int *pCell;

	pCell = GetCellPointer(pOrigin, col, row, nCols);
	*pCell = x;

}

//*****************************
// Compute Levenshtein distance
//*****************************

int StringDistance::LD(char const *s, char const *t)
{
	int *d; // pointer to matrix
	int n; // length of s
	int m; // length of t
	int i; // iterates through s
	int j; // iterates through t
	char s_i; // ith character of s
	char t_j; // jth character of t
	int cost; // cost
	int result; // result
	int cell; // contents of target cell
	int above; // contents of cell immediately above
	int left; // contents of cell immediately to left
	int diag; // contents of cell immediately above and to left
	int sz; // number of cells in matrix

	// Step 1	

	n = strlen(s);
	m = strlen(t);
	if (n == 0) {
		return m;
	}
	if (m == 0) {
		return n;
	}
	sz = (n + 1) * (m + 1) * sizeof(int);
	d = (int *)malloc(sz);

	// Step 2

	for (i = 0; i <= n; i++) {
		PutAt(d, i, 0, n, i);
	}

	for (j = 0; j <= m; j++) {
		PutAt(d, 0, j, n, j);
	}

	// Step 3

	for (i = 1; i <= n; i++) {

		s_i = s[i - 1];

		// Step 4

		for (j = 1; j <= m; j++) {

			t_j = t[j - 1];

			// Step 5

			if (s_i == t_j) {
				cost = 0;
			}
			else {
				cost = 1;
			}

			// Step 6 

			above = GetAt(d, i - 1, j, n);
			left = GetAt(d, i, j - 1, n);
			diag = GetAt(d, i - 1, j - 1, n);
			cell = Minimum(above + 1, left + 1, diag + cost);
			PutAt(d, i, j, n, cell);
		}
	}

	// Step 7

	result = GetAt(d, n, m, n);
	free(d);
	return result;

}

	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\StringDistance.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\StringDistance.h
	 */


#pragma once
#include <string.h>
#include <malloc.h>

class StringDistance
{
public:
	static int LD(char const *s, char const *t);
private:
	static int Minimum(int a, int b, int c);
	static int *GetCellPointer(int *pOrigin, int col, int row, int nCols);
	static int GetAt(int *pOrigin, int col, int row, int nCols);
	static void PutAt(int *pOrigin, int col, int row, int nCols, int x);
};


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\StringDistance.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Task.cpp
	 */


#include "Task.h"


Task::Task(string taskDetails,
	Date *taskStartTime,
	Date *taskEndTime,
	Date *taskDeadline,
	Task::Priority taskPriority){
	_taskDetails = taskDetails;
	_taskStartTime = taskStartTime;
	_taskEndTime = taskEndTime;
	_taskDeadline = taskDeadline;
	_taskPriority = taskPriority;
	_taskMarked = false;

	if (_taskStartTime == NULL && _taskEndTime == NULL && _taskDeadline == NULL) {
		_taskType = FLOATING;
	}

	else if (_taskDeadline == NULL) {
		_taskType = TIMED;
	}

	else {
		_taskType = DEADLINE;
	}
}

Task Task::clone(){
	Task task = Task(_taskDetails, _taskStartTime,
		_taskEndTime, _taskDeadline, _taskPriority);
	task.setTaskMarked(getTaskMarked());
	return task;
}

//Destructor
Task::~Task(){
}

//Modifiers
void Task::setTaskDetails(string taskDetails){
	_taskDetails = taskDetails;
}

void Task::setTaskStartTime(Date* taskStartTime){
	_taskStartTime = taskStartTime;
}

void Task::setTaskEndTime(Date* taskEndTime){
	_taskEndTime = taskEndTime;
}

void Task::setTaskDeadline(Date* taskDeadline){
	_taskDeadline = taskDeadline;
}

void Task::setTaskPriority(Priority taskPriority){
	_taskPriority = taskPriority;
}

void Task::setTaskMarked(bool taskMarked){
	_taskMarked = taskMarked;
}

//Accessors
Task::Type Task::getTaskType(){
	return _taskType;
}

string Task::getTaskDetails(){
	return _taskDetails;
}

Date* Task::getTaskStartTime(){
	return _taskStartTime;
}

Date* Task::getTaskEndTime(){
	return _taskEndTime;
}

Date* Task::getTaskDeadline(){
	return _taskDeadline;
}

Task::Priority Task::getTaskPriority(){
	return _taskPriority;
}

bool Task::getTaskMarked(){
	return _taskMarked;
}
	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Task.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Task.h
	 */

#pragma once

#include <string>
#include <chrono>
#include "Date.h"

using namespace std;

class Task{

public:
	enum Type {
		TIMED, DEADLINE, FLOATING
	};

	enum Priority {
		NORMAL, HIGH
	};

	//Constructor
	Task::Task(string taskDetails,
		Date *taskStartTime,
		Date *taskEndTime,
		Date *taskDeadline,
		Task::Priority taskPriority);

	//Destructor
	Task::~Task();

	Task clone();

	//Modifiers
	void Task::setTaskDetails(string taskDetails);
	void Task::setTaskStartTime(Date* taskStartTime);
	void Task::setTaskEndTime(Date* taskEndTime);
	void Task::setTaskDeadline(Date* taskDeadline);
	void Task::setTaskPriority(Priority taskPriority);
	void Task::setTaskMarked(bool taskMarked);

	//Accessors
	Task::Type Task::getTaskType();
	string Task::getTaskDetails();
	Date* Task::getTaskStartTime();
	Date* Task::getTaskEndTime();
	Date* Task::getTaskDeadline();
	Task::Priority Task::getTaskPriority();
	bool Task::getTaskMarked();

private:
	Task::Type _taskType;
	string _taskDetails;
	Date *_taskStartTime;
	Date *_taskEndTime;
	Date *_taskDeadline;
	Task::Priority _taskPriority;
	bool _taskMarked;
};
	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\Task.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\TaskManager.cpp
	 */


/*
This class is used to manage Taskky's representation of all current Tasks
It is a singleton class, so that there will only be 1 instance of the tasks

When a task is added, it is auto sorted following this method:
1. Timed tasks come first, in chronological then alphabetical order
2. Floating tasks come next, in alphabetical order
3. Marked timed tasks come next, in chronological then alphabetical order
4. Marked floating tasks come last

This class also has functions to supports mark, unmark, deletion and finding
the insertion point of tasks into Taskky's internal representation of Tasks
*/

#include "TaskManager.h"


/*
* ====================================================================
*  Main Program
* ====================================================================
*/

//Loading all the current tasks into Taskky from a vector<Task>
//
//@param the vector of tasks you want to load from
void TaskManager::loadAllCurrentTasks(vector<Task> allCurrentTasks){

	vector<Task>::iterator iterTasks;

	clearAllCurrentTasks();

	for (iterTasks = allCurrentTasks.begin();
		iterTasks != allCurrentTasks.end(); ++iterTasks){

		addTask(*iterTasks);

	}
}


//Adds a task into the appropriate vector, based on its type
//
//@param the task you want to add into Taskky
void TaskManager::addTask(Task task){

	int indexToInsert = getIndex(task);

	vector<Task>* vectorToInsert = getVector(task);

	vectorToInsert->insert(vectorToInsert->begin()
		+ indexToInsert, task);

	setAllCurrentTasks();
}


//Accesses and gets a task based on its task number displayed on screen
//
//@param the task number on screen to get the task from
Task TaskManager::getTask(int taskNumber){

	if (taskNumber>_allCurrentTasks->size()){

		throw CommandException(ERROR_MESSAGE_COMMAND_TASKNUM);

	}

	return _allCurrentTasks->at(taskNumber - 1);
}


//Removes a task based on its task number displayed on screen
//
//@param the task number on screen you want to remove
void TaskManager::removeTask(int taskNumber){

	//Getting the sizes of all the vectors
	int timedTaskSize = _allTimedTasks->size();
	int floatingTaskSize = _allFloatingTasks->size();
	int markedTimedTaskSize = _allMarkedTimedTasks->size();
	int markedFloatingTaskSize = _allMarkedFloatingTasks->size();

	if (taskNumber <= timedTaskSize){

		_allTimedTasks->erase(_allTimedTasks->begin() + taskNumber - 1);

	}

	else if (taskNumber <= timedTaskSize + floatingTaskSize){

		int index = taskNumber - 1 - timedTaskSize;

		_allFloatingTasks->erase(_allFloatingTasks->begin() + index);

	}

	else if (taskNumber <= timedTaskSize +
		floatingTaskSize + markedTimedTaskSize){

		int index = taskNumber - 1 - timedTaskSize - floatingTaskSize;

		_allMarkedTimedTasks->erase(_allMarkedTimedTasks->begin() + index);

	}

	else if (taskNumber <= timedTaskSize + floatingTaskSize + markedTimedTaskSize +
		markedFloatingTaskSize){

		int index = taskNumber - 1 - timedTaskSize -
			floatingTaskSize - markedTimedTaskSize;

		_allMarkedFloatingTasks->erase(_allMarkedFloatingTasks->begin() + index);

	}

	else{

		throw CommandException(ERROR_MESSAGE_COMMAND_TASKNUM);

	}

	setAllCurrentTasks();
}


//Marks a task based on its task number displayed on screen
//
//@param the task number on screen you want to mark
void TaskManager::markTask(int taskNumber){

	Task task = getTask(taskNumber);

	task.setTaskMarked(true);

	removeTask(taskNumber);

	addTask(task);

	setAllCurrentTasks();

}


//Unmarks a task based on its task number displayed on screen
//
//@param the task number on screen you want to unmark
void TaskManager::unmarkTask(int taskNumber){

	Task task = getTask(taskNumber);

	task.setTaskMarked(false);

	removeTask(taskNumber);

	addTask(task);

	setAllCurrentTasks();
}


//Writes the task storage to file
void TaskManager::saveTasks(){

	Storage* storage = Storage::getInstance();

	storage->writeToFile();

}


//Gets the number of task internally
int TaskManager::getNumberOfTasks(){

	if (_allCurrentTasks->size() == 0){

		return 0;

	}

	else{

		return _allCurrentTasks->size();

	}
}

void TaskManager::clearAllCurrentTasks(){

	_allTimedTasks = new vector<Task>;
	_allFloatingTasks = new vector<Task>;
	_allMarkedTimedTasks = new vector<Task>;
	_allMarkedFloatingTasks = new vector<Task>;
	setAllCurrentTasks();

}



/*
* ====================================================================
*  Second Level of Abstraction
* ====================================================================
*/

//Updating the allCurrentTasks vector to reflect an addition of the 4 
//other vector<task> that stores my data
void TaskManager::setAllCurrentTasks(){

	//reset all current tasks
	_allCurrentTasks->clear();

	//iterate through _allTimedTasks first
	for (unsigned int i = 0; i < _allTimedTasks->size(); i++){
		_allCurrentTasks->push_back(_allTimedTasks->at(i));
	}

	//iterate through _allFloatingTasks next
	for (unsigned int i = 0; i < _allFloatingTasks->size(); i++){
		_allCurrentTasks->push_back(_allFloatingTasks->at(i));
	}

	//iterate through _allMarkedTimedTasks next
	for (unsigned int i = 0; i < _allMarkedTimedTasks->size(); i++){
		_allCurrentTasks->push_back(_allMarkedTimedTasks->at(i));
	}

	//iterate through _allMarkedFloatingTasks next
	for (unsigned int i = 0; i < _allMarkedFloatingTasks->size(); i++){
		_allCurrentTasks->push_back(_allMarkedFloatingTasks->at(i));
	}
}







int TaskManager::getIndex(Task task){

	TaskType taskType = determineTaskType(task);

	//task should be added to the _allTimedTasks vector
	if (taskType == TaskType::Timed){

		return getTimedIndexToInsert(task, _allTimedTasks);

	}

	//task should be added to the _allFloatingTasks vector
	else if (taskType == TaskType::Floating){

		return getFloatingIndexToInsert(task, _allFloatingTasks);

	}

	//task should be added to the _allMarkedTimedTasks vector
	else if (taskType == TaskType::MarkedTimed){

		return getTimedIndexToInsert(task, _allMarkedTimedTasks);

	}

	//task should be added to the _allMarkedFloatingTasks vector
	else{

		return getFloatingIndexToInsert(task, _allMarkedFloatingTasks);

	}

}


//Finding the vector to add this new Task
//
//@param the Task that you want to insert
//@return the vector in _allCurrentTasks that you should insert the task in
vector<Task>* TaskManager::getVector(Task task){

	TaskType taskType = determineTaskType(task);

	//task should be added to the _allTimedTasks vector
	if (taskType == TaskType::Timed){

		return _allTimedTasks;

	}

	//task should be added to the _allFloatingTasks vector
	else if (taskType == TaskType::Floating){

		return _allFloatingTasks;

	}

	//task should be added to the _allMarkedTimedTasks vector
	else if (taskType == TaskType::MarkedTimed){

		return _allMarkedTimedTasks;

	}

	//task should be added to the _allMarkedFloatingTasks vector
	else{

		return _allMarkedFloatingTasks;

	}
}


//Finding the vector index to add this new Task
//
//@param the Task that you want to insert
//@return the index in _allCurrentTasks that you should insert the task in
int TaskManager::getIndexToInsert(Task task){

	int indexAddedTo = 0;

	TaskType taskType = determineTaskType(task);

	//task should be added to the _allTimedTasks vector
	if (taskType == TaskType::Timed){

		indexAddedTo += getTimedIndexToInsert(task, _allTimedTasks);

	}

	//task should be added to the _allFloatingTasks vector
	else if (taskType == TaskType::Floating){

		indexAddedTo += getFloatingIndexToInsert(task, _allFloatingTasks);
		//account for the fact that all floating tasks will be below in the vector
		indexAddedTo += _allTimedTasks->size();

	}

	//task should be added to the _allMarkedTimedTasks vector
	else if (taskType == TaskType::MarkedTimed){

		indexAddedTo += getTimedIndexToInsert(task, _allMarkedTimedTasks);
		indexAddedTo += _allTimedTasks->size() + _allFloatingTasks->size();

	}

	//task should be added to the _allMarkedFloatingTasks vector
	else{

		indexAddedTo += getFloatingIndexToInsert(task, _allMarkedFloatingTasks);
		indexAddedTo += _allTimedTasks->size() + _allFloatingTasks->size() +
			_allMarkedTimedTasks->size();

	}

	return indexAddedTo;
}


//Determining the task type of the task that you want to insert
//
//@param the Task that you want to insert
//@return the TaskType of the Task you want to insert
TaskManager::TaskType TaskManager::determineTaskType(Task task){

	if ((task.getTaskType() == Task::DEADLINE ||
		task.getTaskType() == Task::TIMED) && !task.getTaskMarked()){

		return TaskType::Timed;

	}

	else if ((task.getTaskType() == Task::FLOATING) &&
		!task.getTaskMarked()){

		return TaskType::Floating;

	}

	else if (task.getTaskType() == Task::DEADLINE ||
		task.getTaskType() == Task::TIMED){

		return TaskType::MarkedTimed;

	}

	else{

		return TaskType::MarkedFloating;

	}
}


//Finding the vector index in the floating tasks vector to add this task
//The floating task vector is a subset of all current tasks
//
//@param the Task that you want to insert, the floating task vector you want to insert to
//@return the index in the floating task vector that you should add the task in
int TaskManager::getFloatingIndexToInsert(Task task, vector<Task>* floatingTasks){

	vector<Task>::iterator iterFloating;
	int addedIndex = 0;

	if (!floatingTasks->empty()) {

		for (iterFloating = floatingTasks->begin();
			iterFloating != floatingTasks->end(); ++iterFloating) {

			if (isAlphabeticallyArranged(task, *iterFloating)) {
				break;
			}

			addedIndex++;
		}
	}

	return addedIndex;
}


//Finding the vector index in the timed tasks vector to add this task
//The timed task vector is a subset of all current tasks
//
//@param the Task that you want to insert
//@return the index in the timed task vector that you should insert the task in
int TaskManager::getTimedIndexToInsert(Task task, vector<Task>* timedTasks){

	vector<Task>::iterator iterTimed;
	int addedIndex = 0;

	if (!timedTasks->empty()) {

		for (iterTimed = timedTasks->begin();
			iterTimed != timedTasks->end(); ++iterTimed) {

			if (isChronologicallyArranged(task, *iterTimed)){

				if (isChronologicallySame(task, *iterTimed)){

					if (isAlphabeticallyArranged(task, *iterTimed)){
						break;
					}
					else{
						addedIndex++;
						continue;
					}

				}

				break;
			}

			addedIndex++;
		}
	}

	return addedIndex;
}


//Finding out if first task and second task are arranged in alphabetical order
//
//@param the 2 tasks, firstTask and secondTask, that you want to compare in alphabetical order
//@return if the firstTask comes earlier alphabetically than the secondTask
bool TaskManager::isAlphabeticallyArranged(Task firstTask, Task secondTask){

	return firstTask.getTaskDetails().compare(secondTask.getTaskDetails()) < 0;

}


//Finding out if first task and second task are arranged in chronological order
//
//@param the 2 tasks, firstTask and secondTask, that you want to compare in chronological order
//		 both tasks can be either timed or deadline tasks
//@return if the firstTask comes earlier chronologically than the secondTask
bool TaskManager::isChronologicallyArranged(Task firstTask, Task secondTask){

	if (firstTask.getTaskType() == Task::TIMED) {

		if (secondTask.getTaskType() == Task::DEADLINE) {

			if (firstTask.getTaskStartTime()->isEarlierThan(*(secondTask.getTaskDeadline())) >= 0) {
				return true;
			}
		}

		else if (secondTask.getTaskType() == Task::TIMED) {

			if (firstTask.getTaskStartTime()->isEarlierThan(*(secondTask.getTaskStartTime())) >= 0) {
				return true;
			}
		}

		else{
			//throw TaskException
		}
	}

	else if (firstTask.getTaskType() == Task::DEADLINE) {

		if (secondTask.getTaskType() == Task::DEADLINE) {

			if (firstTask.getTaskDeadline()->isEarlierThan(*(secondTask.getTaskDeadline())) >= 0) {
				return true;
			}
		}

		else if (secondTask.getTaskType() == Task::TIMED) {

			if (firstTask.getTaskDeadline()->isEarlierThan(*(secondTask.getTaskStartTime())) >= 0) {
				return true;
			}
		}
	}

	return false;
}



bool TaskManager::isChronologicallySame(Task firstTask, Task secondTask){

	if (firstTask.getTaskType() == Task::TIMED) {

		if (secondTask.getTaskType() == Task::DEADLINE) {

			if (firstTask.getTaskStartTime()->isEarlierThan(*(secondTask.getTaskDeadline())) == 0) {
				return true;
			}
		}

		else if (secondTask.getTaskType() == Task::TIMED) {

			if (firstTask.getTaskStartTime()->isEarlierThan(*(secondTask.getTaskStartTime())) == 0) {
				return true;
			}
		}

		else{
			//throw TaskException
		}
	}

	else if (firstTask.getTaskType() == Task::DEADLINE) {

		if (secondTask.getTaskType() == Task::DEADLINE) {

			if (firstTask.getTaskDeadline()->isEarlierThan(*(secondTask.getTaskDeadline())) == 0) {
				return true;
			}
		}

		else if (secondTask.getTaskType() == Task::TIMED) {

			if (firstTask.getTaskDeadline()->isEarlierThan(*(secondTask.getTaskStartTime())) == 0) {
				return true;
			}
		}
	}

	return false;

}









/*
* ====================================================================
*  Constructor, Getters and Setters
* ====================================================================
*/

TaskManager::TaskManager()
{
}

//Ensures the Singleton pattern is adhered to
TaskManager* TaskManager::getInstance(){
	if (!_instance)
		_instance = new TaskManager;
	return _instance;
}

vector<Task>* TaskManager::getAllCurrentTasks(){
	return _allCurrentTasks;
}

vector<Task>* TaskManager::getAllTimedTasks(){
	return _allTimedTasks;
}

vector<Task>* TaskManager::getAllFloatingTasks(){
	return _allFloatingTasks;
}

vector<Task>* TaskManager::getAllMarkedTimedTasks(){
	return _allMarkedTimedTasks;
}

vector<Task>* TaskManager::getAllMarkedFloatingTasks(){
	return _allMarkedFloatingTasks;
}


/*
* ====================================================================
*  Variables and Messages Declaration
* ====================================================================
*/

// Global static pointer used to ensure a single instance of the class.
TaskManager* TaskManager::_instance = NULL;

//vector representing all the tasks in order
vector<Task>* TaskManager::_allCurrentTasks = new vector<Task>;

//vectors representing the different categories of tasks
vector<Task>* TaskManager::_allTimedTasks = new vector<Task>;
vector<Task>* TaskManager::_allFloatingTasks = new vector<Task>;
vector<Task>* TaskManager::_allMarkedTimedTasks = new vector<Task>;
vector<Task>* TaskManager::_allMarkedFloatingTasks = new vector<Task>;

const string TaskManager::ERROR_MESSAGE_COMMAND_TASKNUM = "Invalid task number!";
	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\TaskManager.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\TaskManager.h
	 */

#pragma once
#include <string>
#include <algorithm>
#include <vector>
#include "Task.h"
#include "Storage.h"
#include "CommandException.h"

using namespace std;
class TaskManager
{
public:

	enum TaskType {
		Timed, Floating, MarkedTimed, MarkedFloating
	};

	static vector<Task>* getAllCurrentTasks();
	static vector<Task>* getAllTimedTasks();
	static vector<Task>* getAllFloatingTasks();
	static vector<Task>* getAllMarkedTimedTasks();
	static vector<Task>* getAllMarkedFloatingTasks();

	static int getNumberOfTasks();
	static TaskManager* getInstance();

	static void addTask(Task task);
	static int addFloatingTask(Task task, vector<Task>* floatingTasks);
	static int addTimedTask(Task task, vector<Task>* timedTasks);

	static Task getTask(int taskNumber);
	static void removeTask(int taskNumber);
	static void TaskManager::saveTasks();
	static void TaskManager::markTask(int taskNumber);
	static void TaskManager::unmarkTask(int taskNumber);
	static void setAllCurrentTasks();
	static void loadAllCurrentTasks(vector<Task> allCurrentTasks);
	static void clearAllCurrentTasks();

	static TaskType determineTaskType(Task task);

	static int TaskManager::getIndex(Task task);
	static vector<Task>* TaskManager::getVector(Task task);

	static int getIndexToInsert(Task task);
	static int getFloatingIndexToInsert(Task task, vector<Task>* floatingTasks);
	static int getTimedIndexToInsert(Task task, vector<Task>* timedTasks);
	static bool isAlphabeticallyArranged(Task firstTask, Task secondTask);
	static bool isChronologicallyArranged(Task firstTask, Task secondTask);
	static bool isChronologicallySame(Task firstTask, Task secondTask);

	static const string TaskManager::ERROR_MESSAGE_COMMAND_TASKNUM;

private:
	TaskManager();

	static vector<Task>* _allCurrentTasks;
	static vector<Task>* TaskManager::_allFloatingTasks;
	static vector<Task>* TaskManager::_allTimedTasks;
	static vector<Task>* TaskManager::_allMarkedFloatingTasks;
	static vector<Task>* TaskManager::_allMarkedTimedTasks;

	//copy constructor is private
	TaskManager& operator=(TaskManager const&){};

	static TaskManager *_instance;
};



	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\TaskManager.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\LogicTests\CommandBuilderTests.cpp
	 */

#pragma once
#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace LogicTest
{
	TEST_CLASS(CommandBuilderTests)
	{
	public:

		TEST_METHOD(CommandBuilderTest1)
		{
			//checking that commandBuilder is cleared properly to be used by the next iteration
			CommandBuilder commandBuilder = CommandBuilder::CommandBuilder();
			Assert::AreEqual<bool>(true, commandBuilder.getTaskDetails() == "");
			Assert::AreEqual<bool>(true, commandBuilder.getTaskDeadline() == nullptr);
			Assert::AreEqual<bool>(true, commandBuilder.getTaskStartTime() == nullptr);
			Assert::AreEqual<bool>(true, commandBuilder.getTaskEndTime() == nullptr);
			Assert::AreEqual<bool>(true, commandBuilder.getTaskPriority() == Task::NORMAL);
			Assert::AreEqual<bool>(true, commandBuilder.getTaskMarked() == false);
			Assert::AreEqual<bool>(true, commandBuilder.getTaskNumber() == -1);

			//Checking constructing of a add command properly
			Command* addCommand = commandBuilder.parseCommand("add hello");
			//Assert::AreEqual<std::string>("CommandAdd", typeid(addCommand).name());
			Assert::AreEqual<std::string>("Task has been added!", addCommand->execute());

			//Checking constructing of a delete command properly
			//Command* deleteCommand = commandBuilder.parseCommand("delete 1");
			//Assert::AreEqual<std::string>("Deleted Task #%d", deleteCommand->execute());

			//Checking constructing of an update command properly
			//Command* updateCommand = commandBuilder.parseCommand("update 1");
			//Assert::AreEqual<std::string>("Deleted Task #%d", updateCommand->execute());



			Assert::AreEqual<bool>(true, CommandBuilder::CommandType::Add ==
				CommandBuilder::determineCommandType("add"));
			Assert::AreEqual<bool>(true, CommandBuilder::CommandType::Display ==
				CommandBuilder::determineCommandType("display"));
			Assert::AreEqual<bool>(true, CommandBuilder::CommandType::Update ==
				CommandBuilder::determineCommandType("update"));
			Assert::AreEqual<bool>(true, CommandBuilder::CommandType::Delete ==
				CommandBuilder::determineCommandType("delete"));
			Assert::AreEqual<bool>(true, CommandBuilder::CommandType::Exit ==
				CommandBuilder::determineCommandType("exit"));
			Assert::AreEqual<bool>(true, CommandBuilder::CommandType::Undo ==
				CommandBuilder::determineCommandType("undo"));
			Assert::AreEqual<bool>(true, CommandBuilder::CommandType::Mark ==
				CommandBuilder::determineCommandType("mark"));
			Assert::AreEqual<bool>(true, CommandBuilder::CommandType::Unmark ==
				CommandBuilder::determineCommandType("unmark"));
			Assert::AreEqual<bool>(true, CommandBuilder::CommandType::Search ==
				CommandBuilder::determineCommandType("search"));
			Assert::AreEqual<bool>(true, CommandBuilder::CommandType::CheckFileLocation ==
				CommandBuilder::determineCommandType("checkfileloc"));
			Assert::AreEqual<bool>(true, CommandBuilder::CommandType::ChangeFileLocation ==
				CommandBuilder::determineCommandType("changefileloc"));


		}

	};
}
	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\LogicTests\CommandBuilderTests.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\LogicTests\StringDistanceTest.cpp
	 */

#pragma once
#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace LogicTest
{
	TEST_CLASS(SuggestionBuilderTest){
	public:
<<<<<<< HEAD
		TEST_METHOD(StringDistanceTest1){
			Assert::AreEqual<int>(0, StringDistance::LD("hello", "hello"));
			Assert::AreEqual<int>(1, StringDistance::LD("hello", "hell"));
			Assert::AreEqual<int>(2, StringDistance::LD("hello", "helol"));
			Assert::AreEqual<int>(2, StringDistance::LD("hello", "hlo"));
=======
		TEST_METHOD(SuggestionBuilderTest1){
			//Testing extreme cases of suggested command types
			//Assert::AreEqual<bool>(true, SuggestionBuilder::suggestCommandType("") == "");

			//Testing parsing of suggested command types for add, different extreme cases
			Assert::AreEqual<bool>(true, SuggestionBuilder::suggestCommandType(" a") == "add");
			Assert::AreEqual<bool>(true, SuggestionBuilder::suggestCommandType("a") == "add");
			Assert::AreEqual<bool>(true, SuggestionBuilder::suggestCommandType("a ") == "add");
			Assert::AreEqual<bool>(true, SuggestionBuilder::suggestCommandType("ad") == "add");
			Assert::AreEqual<bool>(true, SuggestionBuilder::suggestCommandType("add") == "add");
			Assert::AreEqual<bool>(true, SuggestionBuilder::suggestCommandType("add hello ") == "add");

			//Testing parsing of suggested command types for all other command types
			Assert::AreEqual<bool>(true, SuggestionBuilder::suggestCommandType("del") == "delete");
			Assert::AreEqual<bool>(true, SuggestionBuilder::suggestCommandType("disp") == "display");
			Assert::AreEqual<bool>(true, SuggestionBuilder::suggestCommandType("exit") == "exit");
			Assert::AreEqual<bool>(true, SuggestionBuilder::suggestCommandType("mar") == "mark");
			Assert::AreEqual<bool>(true, SuggestionBuilder::suggestCommandType("und") == "undo");
			Assert::AreEqual<bool>(true, SuggestionBuilder::suggestCommandType("upd") == "update");
			Assert::AreEqual<bool>(true, SuggestionBuilder::suggestCommandType("unm") == "unmark");


			//Testing suggestion of entire user input
			Assert::AreEqual<bool>(true, SuggestionBuilder::
				suggestUserInput("add hello b sat") == "add hello by saturday");
			Assert::AreEqual<bool>(true, SuggestionBuilder::
				suggestUserInput("add hello fr sat t") == "add hello from saturday to ");
			Assert::AreEqual<bool>(true, SuggestionBuilder::
				suggestUserInput("del ") == "delete");
			Assert::AreEqual<bool>(true, SuggestionBuilder::
				suggestUserInput("del 1") == "delete");
			Assert::AreEqual<bool>(true, SuggestionBuilder::
				suggestUserInput("dis") == "display");
>>>>>>> origin/master
		}
	};
}
	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\LogicTests\StringDistanceTest.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\LogicTests\TaskManagerTest.cpp
	 */

#pragma once
#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace LogicTest
{
	TEST_CLASS(TaskManagerTest){
public:
	TEST_METHOD(TaskManagerConstructorTest)
	{
		//checking both instances are the same, singleton class
		TaskManager* instance1 = TaskManager::getInstance();
		TaskManager* instance2 = TaskManager::getInstance();
		Assert::AreEqual<bool>(true, typeid(*instance1) == typeid(*instance2));
	}
	TEST_METHOD(TaskManagerAddTest)
	{
		TaskManager* instance = TaskManager::getInstance();
		instance->clearAllCurrentTasks();
		Assert::AreEqual<int>(0, instance->getNumberOfTasks());

		//tasks to be added
		Date* earlyDate = new Date(2015, 9, 13, 17, 00);
		Date* middleDate = new Date(2015, 9, 13, 18, 00);
		Date* lateDate = new Date(2015, 9, 13, 19, 00);
		Task firstTask = Task::Task("AAAA", nullptr, nullptr, earlyDate, Task::Priority::HIGH);
		Task secondTask = Task::Task("BBBB", nullptr, nullptr, middleDate, Task::Priority::HIGH);
		Task thirdTask = Task::Task("CCCC", nullptr, nullptr, lateDate, Task::Priority::HIGH);
		Task forthTask = Task::Task("DDDD", nullptr, nullptr, nullptr, Task::Priority::HIGH);
		Task fifthTask = Task::Task("EEEE", nullptr, nullptr, nullptr, Task::Priority::HIGH);

		//testing the add function
		Assert::AreEqual<int>(0, instance->getNumberOfTasks());
		instance->addTask(fifthTask);
		instance->addTask(forthTask);
		instance->addTask(thirdTask);
		instance->addTask(secondTask);
		instance->addTask(firstTask);
		Assert::AreEqual<int>(5, instance->getNumberOfTasks());

		//Checking if tasks are actually added in order
		vector<Task>* allTimedTasks = instance->getAllTimedTasks();
		vector<Task>* allFloatingTasks = instance->getAllFloatingTasks();

		//accessing the actual vector it is updated at
		Assert::AreEqual<string>(firstTask.getTaskDetails(), allTimedTasks->at(0).getTaskDetails());
		Assert::AreEqual<string>(secondTask.getTaskDetails(), allTimedTasks->at(1).getTaskDetails());
		Assert::AreEqual<string>(thirdTask.getTaskDetails(), allTimedTasks->at(2).getTaskDetails());
		Assert::AreEqual<string>(forthTask.getTaskDetails(), allFloatingTasks->at(0).getTaskDetails());
		Assert::AreEqual<string>(fifthTask.getTaskDetails(), allFloatingTasks->at(1).getTaskDetails());

		//accessing the allcurrenttask vector to check
		Assert::AreEqual<string>(firstTask.getTaskDetails(), instance->getTask(1).getTaskDetails());
		Assert::AreEqual<string>(secondTask.getTaskDetails(), instance->getTask(2).getTaskDetails());
		Assert::AreEqual<string>(thirdTask.getTaskDetails(), instance->getTask(3).getTaskDetails());
		Assert::AreEqual<string>(forthTask.getTaskDetails(), instance->getTask(4).getTaskDetails());
		Assert::AreEqual<string>(fifthTask.getTaskDetails(), instance->getTask(5).getTaskDetails());
	}

	TEST_METHOD(TaskManagerSequenceTest)
	{
		//reseting all entered tasks
		TaskManager* instance = TaskManager::getInstance();
		instance->clearAllCurrentTasks();

		//testing alphabet sorting
		Task earlierAlphabet = Task::Task("AAAA", nullptr, nullptr, nullptr, Task::Priority::HIGH);
		Task laterAlphabet = Task::Task("BBBB", nullptr, nullptr, nullptr, Task::Priority::HIGH);
		Assert::AreEqual<bool>(true, instance->isAlphabeticallyArranged(earlierAlphabet, laterAlphabet));

		//testing date sorting with 2 deadline
		Date earlierDate = Date(2015, 9, 13, 17, 00);
		Date laterDate = Date(2015, 9, 13, 18, 00);
		Task earlierTask = Task::Task("AAAA", nullptr, nullptr, &earlierDate, Task::Priority::HIGH);
		Task laterTask = Task::Task("BBBB", nullptr, nullptr, &laterDate, Task::Priority::HIGH);
		Assert::AreEqual<bool>(true, instance->isChronologicallyArranged(earlierTask, laterTask));
		Assert::AreEqual<bool>(false, instance->isChronologicallyArranged(laterTask, earlierTask));

		//testing date sorting with 2 timed
		Date earlierDate2 = Date(2015, 9, 13, 18, 00);
		Date laterDate2 = Date(2015, 9, 13, 19, 00);
		earlierTask = Task::Task("AAAA", &earlierDate, &earlierDate2, nullptr, Task::Priority::HIGH);
		laterTask = Task::Task("BBBB", &laterDate, &laterDate2, nullptr, Task::Priority::HIGH);
		Assert::AreEqual<bool>(true, instance->isChronologicallyArranged(earlierTask, laterTask));
		Assert::AreEqual<bool>(false, instance->isChronologicallyArranged(laterTask, earlierTask));

		//testing date sorting with 1 deadline 1 timed
		earlierTask = Task::Task("AAAA", nullptr, nullptr, &earlierDate, Task::Priority::HIGH);
		laterTask = Task::Task("BBBB", &laterDate, &laterDate2, nullptr, Task::Priority::HIGH);
		Assert::AreEqual<bool>(true, instance->isChronologicallyArranged(earlierTask, laterTask));
		Assert::AreEqual<bool>(false, instance->isChronologicallyArranged(laterTask, earlierTask));

		//testing date sorting with 1 timed 1 deadline
		earlierTask = Task::Task("AAAA", &earlierDate, &earlierDate2, nullptr, Task::Priority::HIGH);
		laterTask = Task::Task("BBBB", nullptr, nullptr, &laterDate, Task::Priority::HIGH);
		Assert::AreEqual<bool>(true, instance->isChronologicallyArranged(earlierTask, laterTask));
		Assert::AreEqual<bool>(false, instance->isChronologicallyArranged(laterTask, earlierTask));

		//testing date sorting with 2 same deadline
		earlierTask = Task::Task("AAAA", nullptr, nullptr, &laterDate, Task::Priority::HIGH);
		laterTask = Task::Task("BBBB", nullptr, nullptr, &laterDate, Task::Priority::HIGH);
		Assert::AreEqual<bool>(true, instance->isChronologicallyArranged(earlierTask, laterTask));
		Assert::AreEqual<bool>(true, instance->isChronologicallyArranged(laterTask, earlierTask));


		//setting up floating vector to insert 
		vector<Task>* floatingVector = new vector < Task >;
		Task earlierAlphabetTask = Task::Task("AAAA", nullptr, nullptr, nullptr, Task::Priority::HIGH);
		Task middleAlphabetTask = Task::Task("BBBB", nullptr, nullptr, nullptr, Task::Priority::HIGH);
		Task laterAlphabetTask = Task::Task("CCC", nullptr, nullptr, nullptr, Task::Priority::HIGH);

		//testing getting later alphabet insert index
		floatingVector->push_back(earlierAlphabetTask);
		floatingVector->push_back(middleAlphabetTask);
		Assert::AreEqual<int>(2, floatingVector->size());
		Assert::AreEqual<int>(2, TaskManager::getFloatingIndexToInsert(laterAlphabetTask, floatingVector));

		//testing getting middle alphabet insert index
		floatingVector->clear();
		floatingVector->push_back(earlierAlphabetTask);
		floatingVector->push_back(laterAlphabetTask);
		Assert::AreEqual<int>(2, floatingVector->size());
		Assert::AreEqual<int>(1, TaskManager::getFloatingIndexToInsert(middleAlphabetTask, floatingVector));

		//testing getting earlier alphabet insert index
		floatingVector->clear();
		floatingVector->push_back(middleAlphabetTask);
		floatingVector->push_back(laterAlphabetTask);
		Assert::AreEqual<int>(2, floatingVector->size());
		Assert::AreEqual<int>(0, TaskManager::getFloatingIndexToInsert(earlierAlphabetTask, floatingVector));


		//setting up timed vector to insert 
		vector<Task>* timedVector = new vector < Task >;
		Date* earlyDate = new Date(2015, 9, 13, 17, 00);
		Date* middleDate = new Date(2015, 9, 13, 18, 00);
		Date* lateDate = new Date(2015, 9, 13, 19, 00);
		Task earlierTimedTask = Task::Task("AAAA", nullptr, nullptr, earlyDate, Task::Priority::HIGH);
		Task middleTimedTask = Task::Task("BBBB", nullptr, nullptr, middleDate, Task::Priority::HIGH);
		Task laterTimedTask = Task::Task("CCC", nullptr, nullptr, lateDate, Task::Priority::HIGH);
		Task middleTimedTaskBeta = Task::Task("DDD", nullptr, nullptr, middleDate, Task::Priority::HIGH);

		//testing getting later timing insert index
		timedVector->push_back(earlierTimedTask);
		timedVector->push_back(middleTimedTask);
		Assert::AreEqual<int>(2, timedVector->size());
		Assert::AreEqual<int>(2, TaskManager::getTimedIndexToInsert(laterTimedTask, timedVector));

		//testing getting middle timing insert index
		timedVector->clear();
		timedVector->push_back(earlierTimedTask);
		timedVector->push_back(laterTimedTask);
		Assert::AreEqual<int>(2, timedVector->size());
		Assert::AreEqual<int>(1, TaskManager::getTimedIndexToInsert(middleTimedTask, timedVector));

		//testing getting earlier timing insert index
		timedVector->clear();
		timedVector->push_back(middleTimedTask);
		timedVector->push_back(laterTimedTask);
		Assert::AreEqual<int>(2, timedVector->size());
		Assert::AreEqual<int>(0, TaskManager::getTimedIndexToInsert(earlierTimedTask, timedVector));

		//testing inserting same deadline tasks into the vector
		timedVector->clear();
		timedVector->push_back(earlierTimedTask);
		timedVector->push_back(middleTimedTask);
		timedVector->push_back(laterTimedTask);
		Assert::AreEqual<int>(3, timedVector->size());
		Assert::AreEqual<int>(2, TaskManager::getTimedIndexToInsert(middleTimedTaskBeta, timedVector));

		//testing inserting same deadline tasks into the vector
		timedVector->clear();
		timedVector->push_back(earlierTimedTask);
		timedVector->push_back(middleTimedTaskBeta);
		timedVector->push_back(laterTimedTask);
		Assert::AreEqual<int>(3, timedVector->size());
		Assert::AreEqual<int>(1, TaskManager::getTimedIndexToInsert(middleTimedTask, timedVector));

		//testing getIndexToInsert
		vector<Task>* allFloatingTasks = instance->getAllFloatingTasks();
		vector<Task>* allTimedTasks = instance->getAllTimedTasks();
		vector<Task>* allMarkedFloatingTasks = instance->getAllMarkedFloatingTasks();
		vector<Task>* allMarkedTimedTasks = instance->getAllMarkedTimedTasks();

	}
	};
}
	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\LogicTests\TaskManagerTest.cpp





