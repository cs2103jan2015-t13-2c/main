//@author: a0114084n



	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\SuggestionBuilder.cpp
	 */


#include "SuggestionBuilder.h"


SuggestionBuilder::SuggestionBuilder()
{
}


SuggestionBuilder::~SuggestionBuilder()
{
}


string SuggestionBuilder::suggestUserInput(string userInput){

	std::transform(userInput.begin(), userInput.end(), userInput.begin(), ::tolower);

	string commandType = suggestCommandType(userInput);

	string suggestedUserInput = commandType;

	return suggestedUserInput;
}


string SuggestionBuilder::suggestCommandType(string userInput){

	if (userInput == ""){

		return "e.g: add, delete, update, search, mark, unmark, undo, checkfilelocation, changefilelocation, help";

	}

	userInput = getFirstWord(userInput);

	if (isPredictedCommandAdd(userInput)){
		return "add cs2103 from 6 may 13:00 to 7 may 14:00 #high";
	}

	else if (isPredictedCommandDelete(userInput)){
		return "delete [taskNumber]";
	}

	else if (isPredictedCommandDisplay(userInput)){
		return "display";
	}

	else if (isPredictedCommandExit(userInput)){
		return "exit";
	}

	else if (isPredictedCommandMark(userInput)){
		return "mark [taskNumber]";
	}

	else if (isPredictedCommandUndo(userInput)){
		return "undo";
	}

	else if (isPredictedCommandUnmark(userInput)){
		return "unmark [taskNumber]";
	}

	else if (isPredictedCommandUpdate(userInput)){
		return "update [taskNumber] details/deadline/starttime/endtime/priority [things to be updated]";
	}
	else if (isPredictedCommandCheckSavedFileLocation(userInput)){
		return "checkfileloc";
	}
	else if (isPredictedChangeFileLocation(userInput)){
		return "changefileloc [New Directory]";
	}
	else if (isPredictedCommandSearch(userInput)){
		return "search next available [xx day yy hour zz min]";
	}
	else if (isPredictedCommandHelp(userInput)){
		return "Help : Press F1";
	}

	return "invalid";

}




bool SuggestionBuilder::isPredictedCommandAdd(string userInput){

	if (userInput == "a" || userInput == "ad" || userInput == "add"){
		return true;
	}

	if (StringDistance::LD(userInput.c_str(), "add") <= 1){
		return true;
	}

	return false;

}

bool SuggestionBuilder::isPredictedCommandDelete(string userInput){

	if (userInput == "d" || userInput == "de" ||
		userInput == "del" || userInput == "dele" ||
		userInput == "delet" || userInput == "delete"){
		return true;
	}

	if (StringDistance::LD(userInput.c_str(), "delete") <= 1){
		return true;
	}

	return false;
}


bool SuggestionBuilder::isPredictedCommandDisplay(string userInput){

	if (userInput == "d" || userInput == "di" ||
		userInput == "dis" || userInput == "disp" ||
		userInput == "displ" || userInput == "display"){
		return true;
	}

	if (StringDistance::LD(userInput.c_str(), "display") <= 1){
		return true;
	}

	return false;
}

bool SuggestionBuilder::isPredictedCommandExit(string userInput){

	if (userInput == "e" || userInput == "ex" ||
		userInput == "exi" || userInput == "exit"){
		return true;
	}

	if (StringDistance::LD(userInput.c_str(), "exit") <= 1){
		return true;
	}

	return false;
}


bool SuggestionBuilder::isPredictedCommandMark(string userInput){

	if (userInput == "m" || userInput == "ma" ||
		userInput == "mar" || userInput == "mark"){
		return true;
	}

	if (StringDistance::LD(userInput.c_str(), "mark") <= 1){
		return true;
	}

	return false;
}

bool SuggestionBuilder::isPredictedCommandUndo(string userInput){

	if (userInput == "u" || userInput == "un" ||
		userInput == "und" || userInput == "undo"){
		return true;
	}

	if (StringDistance::LD(userInput.c_str(), "undo") <= 1){
		return true;
	}

	return false;
}

bool SuggestionBuilder::isPredictedCommandUnmark(string userInput){

	if (userInput == "u" || userInput == "un" ||
		userInput == "unm" || userInput == "unma" ||
		userInput == "unmar" || userInput == "unmark"){
		return true;
	}

	if (StringDistance::LD(userInput.c_str(), "unmark") <= 1){
		return true;
	}

	return false;
}

bool SuggestionBuilder::isPredictedCommandUpdate(string userInput){

	if (userInput == "u" || userInput == "up" ||
		userInput == "upd" || userInput == "upda" ||
		userInput == "updat" || userInput == "update"){
		return true;
	}

	if (StringDistance::LD(userInput.c_str(), "update") <= 1){
		return true;
	}

	return false;
}



bool SuggestionBuilder::isPredictedCommandCheckSavedFileLocation(string userInput){

	if (userInput == "c" || userInput == "ch" ||
		userInput == "che" || userInput == "chec" ||
		userInput == "check" || userInput == "checkf" ||
		userInput == "checkfi" || userInput == "checkfil" ||
		userInput == "checkfile" || userInput == "checkfilel" ||
		userInput == "checkfilelo" || userInput == "checkfileloc"){
		return true;
	}

	if (StringDistance::LD(userInput.c_str(), "checkfileloc") <= 1){
		return true;
	}
	return false;
}

bool SuggestionBuilder::isPredictedChangeFileLocation(string userInput){

	if (userInput == "c" || userInput == "ch" ||
		userInput == "cha" || userInput == "chan" ||
		userInput == "chang" || userInput == "change" ||
		userInput == "changef" || userInput == "changefi" ||
		userInput == "changefil" || userInput == "changefile" ||
		userInput == "changefilel" || userInput == "changefilelo" ||
		userInput == "changefileloc"){
		return true;
	}

	if (StringDistance::LD(userInput.c_str(), "checkfileloc") <= 1){
		return true;
	}
	return false;
}

bool SuggestionBuilder::isPredictedCommandSearch(string userInput){
	if (userInput == "s" || userInput == "se" ||
		userInput == "sea" || userInput == "sear" ||
		userInput == "searc" || userInput == "search"){
		return true;
	}

	if (StringDistance::LD(userInput.c_str(), "search") <= 1){
		return true;
	}
	return false;


}

bool SuggestionBuilder::isPredictedCommandHelp(string userInput){
	if (userInput == "h" || userInput == "he" ||
		userInput == "hel" || userInput == "help"){
		return true;
	}

	if (StringDistance::LD(userInput.c_str(), "help") <= 1){
		return true;
	}
	return false;


}


/*
* ====================================================================
*  Additional functions
* ====================================================================
*/
string SuggestionBuilder::removeFirstWord(string userCommand) {
	return trim(replace(userCommand, getFirstWord(userCommand), ""));
}

string SuggestionBuilder::getFirstWord(string userCommand) {
	string commandTypeString = splitParameters(userCommand)[0];
	return commandTypeString;
}

// This method only split string based on delimiter space
vector<string> SuggestionBuilder::splitParameters(string commandParametersString){
	vector<string> tokens;
	istringstream iss(commandParametersString);
	copy(istream_iterator<string>(iss),
		istream_iterator<string>(),
		back_inserter<vector<string> >(tokens));

	return tokens;
}

inline string SuggestionBuilder::trim_right(const string& s, const string& delimiters) {
	return s.substr(0, s.find_last_not_of(delimiters) + 1);
}

inline string SuggestionBuilder::trim_left(const string& s, const string& delimiters) {
	return s.substr(s.find_first_not_of(delimiters));
}

inline string SuggestionBuilder::trim(const string& s, const string& delimiters) {
	if (!s.empty())
		return trim_left(trim_right(s, delimiters), delimiters);
	else
		return s;
}

bool SuggestionBuilder::equalsIgnoreCase(const string& str1, const string& str2) {
	if (str1.size() != str2.size()) {
		return false;
	}
	for (string::const_iterator c1 = str1.begin(), c2 = str2.begin(); c1 != str1.end(); ++c1, ++c2) {
		if (tolower(*c1) != tolower(*c2)) {
			return false;
		}
	}
	return true;
}

int SuggestionBuilder::parseInt(string str) {
	char c;
	int i = 0;
	std::stringstream ss(str);
	ss >> i;
	if (ss.fail() || ss.get(c)) {
		return -1;
	}
	else {
		return i;
	}
}

string SuggestionBuilder::replace(string a, string b, string c) {
	int pos;
	do {
		pos = a.find(b);
		if (pos != -1)  a.replace(pos, b.length(), c);
	} while (pos != -1);
	return a;
}

	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\SuggestionBuilder.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\SuggestionBuilder.h
	 */

#pragma once
#include <string>
#include <algorithm>
#include "CommandBuilder.h"
#include "ParseException.h"
#include "StringDistance.h"

using namespace std;

class SuggestionBuilder
{
public:
	SuggestionBuilder();
	~SuggestionBuilder();

	static string suggestUserInput(string userInput);
	static string suggestCommandType(string userInput);
	
	//static string commandToString(CommandBuilder::CommandType commandType);


	static bool isPredictedCommandAdd(string userInput);
	static bool isPredictedCommandDelete(string userInput);
	static bool isPredictedCommandDisplay(string userInput);
	static bool isPredictedCommandExit(string userInput);
	static bool isPredictedCommandMark(string userInput);
	static bool isPredictedCommandUndo(string userInput);
	static bool isPredictedCommandUnmark(string userInput);
	static bool isPredictedCommandUpdate(string userInput);
	static bool isPredictedCommandCheckSavedFileLocation(string userInput);
	static bool isPredictedChangeFileLocation(string userInput);
	static bool isPredictedCommandSearch(string userInput);
	static bool isPredictedCommandHelp(string userInput);


	//getting predicted keywords
	static string predictedKeyword(string text);
	static bool isPredictedFrom(string userInput);
	static bool isPredictedTo(string userInput);
	static bool isPredictedNext(string userInput);
	static bool isPredictedBy(string userInput);
	static bool isPredictedThis(string userInput);
	static bool isPredictedEvery(string userInput);


	static string predictedDate(string text);

	/*
	static const string TASK_NUMBER_SUGGESTION;
	static const string TASK_DETAILS_SUGGESTION;
	static const string TASK_DATE_SUGGESTION;
	static const string TASK_DATE_SUGGESTION;
	*/

	static string removeFirstWord(string userCommand);
	static string getFirstWord(string userCommand);
	static vector<string> splitParameters(string commandParametersString);
	static string trim_right(const string& s, const string& delimiters = " \f\n\r\t\v");
	static string trim_left(const string& s, const string& delimiters = " \f\n\r\t\v");
	static string trim(const string& s, const string& delimiters = " \f\n\r\t\v");
	static bool equalsIgnoreCase(const string& str1, const string& str2);
	static int parseInt(string str);
	static string replace(string a, string b, string c);

};


	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\Logic\SuggestionBuilder.h





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\LogicTests\ControllerTests.cpp
	 */

#pragma once
#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace LogicTest
{
	TEST_CLASS(ControllerTests)
	{
	public:

		TEST_METHOD(ControllerTest1)
		{
			//checking both instances are the same, singleton class
			Controller* instance1 = Controller::getInstance();
			Controller* instance2 = Controller::getInstance();
			Assert::AreEqual<bool>(true, typeid(*instance1) == typeid(*instance2));
		}

	};
}
	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\LogicTests\ControllerTests.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\LogicTests\UtilityTest.cpp
	 */

#pragma once
#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace LogicTest
{
	TEST_CLASS(UtilityTest){
public:

	TEST_METHOD(DateTest)
	{
		Date nowDate = Date(2015, 9, 13, 17, 00);
		Assert::AreEqual<std::string>("13 Oct 2015 (Tue), 05:00PM", nowDate.toString());

		Date earlierDate = Date(2015, 9, 13, 17, 00);
		Date middleDate = Date(2015, 9, 13, 18, 00);
		Date middleDate2 = Date(2015, 9, 13, 18, 00);
		Date laterDate = Date(2015, 9, 13, 19, 00);
		Assert::AreEqual<int>(60, middleDate.diffInMinutes(laterDate));
		Assert::AreEqual<int>(0, middleDate.isEarlierThan(middleDate2));
		Assert::AreEqual<int>(1, middleDate.isEarlierThan(laterDate));
		Assert::AreEqual<int>(-1, middleDate.isEarlierThan(earlierDate));

		//getting year, month, date test
		Assert::AreEqual<int>(2015, nowDate.getYear());
		Assert::AreEqual<int>(9, nowDate.getMonth());
		Assert::AreEqual<int>(13, nowDate.getDay());
		Assert::AreEqual<int>(17, nowDate.getHour());
		Assert::AreEqual<int>(00, nowDate.getMinute());
		//Assert::AreEqual<string>("Tue", nowDate.getDayName());

		//same Date test
		Date tmrDate = Date(2015, 9, 14, 17, 00);
		Assert::AreEqual<bool>(true, earlierDate.sameDate(laterDate));
		Assert::AreEqual<bool>(false, earlierDate.sameDate(tmrDate));
	}

	TEST_METHOD(TaskTest)
	{
		//testing floating task
		Task newFloatingTask = Task::Task("Do Something", nullptr, nullptr, nullptr, Task::Priority::HIGH);
		Assert::AreEqual<std::string>("Do Something", newFloatingTask.getTaskDetails());
		Assert::AreEqual<bool>(true, newFloatingTask.getTaskDeadline() == nullptr);
		Assert::AreEqual<bool>(true, newFloatingTask.getTaskStartTime() == nullptr);
		Assert::AreEqual<bool>(true, newFloatingTask.getTaskEndTime() == nullptr);
		Assert::AreEqual<bool>(true, newFloatingTask.getTaskType() == Task::FLOATING);
		Assert::AreEqual<bool>(true, Task::Priority::HIGH == newFloatingTask.getTaskPriority());

		//testing timed tasks
		Date earlierDate = Date(2015, 10, 13, 17, 00);
		Date laterDate = Date(2015, 10, 13, 18, 00);
		Task newTimedTask = Task::Task("Do Something", &earlierDate, &laterDate, NULL, Task::Priority::HIGH);
		Assert::AreEqual<std::string>("Do Something", newTimedTask.getTaskDetails());
		Assert::AreEqual<bool>(true, newTimedTask.getTaskType() == Task::TIMED);
		Assert::AreEqual<int>(0, newTimedTask.getTaskStartTime()->isEarlierThan(*newTimedTask.getTaskStartTime()));
		Assert::AreEqual<int>(1, newTimedTask.getTaskStartTime()->isEarlierThan(*newTimedTask.getTaskEndTime()));
		Assert::AreEqual<int>(-1, newTimedTask.getTaskEndTime()->isEarlierThan(*newTimedTask.getTaskStartTime()));
	}

	TEST_METHOD(StringDistanceTest)
	{
		Assert::AreEqual<int>(0, StringDistance::LD("hello", "hello"));
		Assert::AreEqual<int>(1, StringDistance::LD("hello", "hell"));
		Assert::AreEqual<int>(2, StringDistance::LD("hello", "helol"));
		Assert::AreEqual<int>(2, StringDistance::LD("hello", "hlo"));
	}
	};
}
	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\LogicTests\UtilityTest.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\TaskkyUI\TaskkyGUI.cpp
	 */

#include "TaskkyGUI.h"


using namespace System;
using namespace System::Windows::Forms;

[STAThread]

void main(array<String^>^ args){
	Application::EnableVisualStyles();
	Application::SetCompatibleTextRenderingDefault(false);
	TaskkyUI::TaskkyGUI mainWindow;
	Application::Run(%mainWindow);
}
	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\TaskkyUI\TaskkyGUI.cpp





	/**
	 * origin: C:\Users\Adi!\Desktop\CS2103\Taskky\TaskkyUI\TaskkyGUI.h
	 */

#pragma once


#include "Parser.h"
#include "Controller.h"
#include <string>
#include <msclr\marshal_cppstd.h>
#include "CommandDisplay.h"
#include "Task.h"
#include "CommandBuilder.h"
#include "CommandMark.h"
#include "TaskkyGUI.h"
#include "Storage.h"
#include "TaskManager.h"
#include "Date.h"

namespace TaskkyUI {

	using namespace System;
	using namespace System::ComponentModel;
	using namespace System::Collections;
	using namespace System::Windows::Forms;
	using namespace System::Data;
	using namespace System::Drawing;

	string command, result, taskdisplay, result2, result3;
	string usernamedisplay;

	public ref class TaskkyGUI : public System::Windows::Forms::Form
	{
	public:
		TaskkyGUI()
		{
			InitializeComponent();

			Controller::initializeComponent();

			vector<Task>* allCurrentTasks = TaskManager::getAllCurrentTasks();

			for (int i = 0; i != allCurrentTasks->size(); i++){

				Task task = (*allCurrentTasks)[i];

				ListViewItem^ newEntry;

				if (task.getTaskType() == Task::FLOATING){

					ListViewItem^ newEntry = addNewItem(i + 1, "--------",
						"--------", task.getTaskDetails(),
						task.getTaskPriority(), task.getTaskMarked());

					array<ListViewItem^>^FloatingTasks = { newEntry };
					listView1->Items->AddRange(FloatingTasks);

				}

				else if (task.getTaskType() == Task::DEADLINE){
					ListViewItem^ newEntry = addNewItem(i + 1,
						task.getTaskDeadline()->toString(),
						"--------", task.getTaskDetails(),
						task.getTaskPriority(), task.getTaskMarked());

					array<ListViewItem^>^DeadlineTasks = { newEntry };
					listView1->Items->AddRange(DeadlineTasks);

				}

				else{

					ListViewItem^ newEntry = addNewItem(i + 1,
						task.getTaskStartTime()->toString(),
						task.getTaskEndTime()->toString(),
						task.getTaskDetails(), task.getTaskPriority(),
						task.getTaskMarked());

					array<ListViewItem^>^TimedTasks = { newEntry };
					listView1->Items->AddRange(TimedTasks);
				}
			}

		}
	private: System::Windows::Forms::Label^  HelpButton;
	public:


	public: System::Windows::Forms::TextBox^  UserInput;


	protected:
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		~TaskkyGUI()
		{
			if (components)
			{
				delete components;
			}
		}
	private: System::Windows::Forms::Label^  TASKKYTitle;
	private: System::Windows::Forms::Label^  CurrentTime;
	private: System::Windows::Forms::Timer^  timer1;
	private: System::Windows::Forms::Label^  SuggestionText;
	private: System::Windows::Forms::Label^  FeedbackUserInput;
	private: System::Windows::Forms::ListView^  listView1;
	private: System::Windows::Forms::ColumnHeader^  TaskNumber;
	private: System::Windows::Forms::ColumnHeader^  StartTime;
	private: System::Windows::Forms::ColumnHeader^  EndTime;
	private: System::Windows::Forms::ColumnHeader^  TaskDetails;
	private: System::Windows::Forms::Label^  UrgentTask;
	private: System::Windows::Forms::Label^  NumberOfUrgentTask;
	private: System::Windows::Forms::Label^  DueToday;
	private: System::Windows::Forms::Label^  NumberOfTaskDueToday;
	private: System::Windows::Forms::Label^  OverdueTask;
	private: System::Windows::Forms::Label^  NumberOfOverdueTask;
	private: System::ComponentModel::IContainer^  components;
	private:
		/// <summary>
		/// Required designer variable.
		/// </summary>


#pragma region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		void InitializeComponent(void)
		{
			this->components = (gcnew System::ComponentModel::Container());
			System::ComponentModel::ComponentResourceManager^  resources = (gcnew System::ComponentModel::ComponentResourceManager(TaskkyGUI::typeid));
			this->UserInput = (gcnew System::Windows::Forms::TextBox());
			this->TASKKYTitle = (gcnew System::Windows::Forms::Label());
			this->CurrentTime = (gcnew System::Windows::Forms::Label());
			this->timer1 = (gcnew System::Windows::Forms::Timer(this->components));
			this->SuggestionText = (gcnew System::Windows::Forms::Label());
			this->FeedbackUserInput = (gcnew System::Windows::Forms::Label());
			this->listView1 = (gcnew System::Windows::Forms::ListView());
			this->TaskNumber = (gcnew System::Windows::Forms::ColumnHeader());
			this->StartTime = (gcnew System::Windows::Forms::ColumnHeader());
			this->EndTime = (gcnew System::Windows::Forms::ColumnHeader());
			this->TaskDetails = (gcnew System::Windows::Forms::ColumnHeader());
			this->UrgentTask = (gcnew System::Windows::Forms::Label());
			this->NumberOfUrgentTask = (gcnew System::Windows::Forms::Label());
			this->DueToday = (gcnew System::Windows::Forms::Label());
			this->NumberOfTaskDueToday = (gcnew System::Windows::Forms::Label());
			this->OverdueTask = (gcnew System::Windows::Forms::Label());
			this->NumberOfOverdueTask = (gcnew System::Windows::Forms::Label());
			this->HelpButton = (gcnew System::Windows::Forms::Label());
			this->SuspendLayout();
			// 
			// UserInput
			// 
			this->UserInput->AutoCompleteCustomSource->AddRange(gcnew cli::array< System::String^  >(3) { L"add", L"delete", L"display" });
			this->UserInput->BackColor = System::Drawing::Color::FromArgb(static_cast<System::Int32>(static_cast<System::Byte>(64)), static_cast<System::Int32>(static_cast<System::Byte>(64)),
				static_cast<System::Int32>(static_cast<System::Byte>(64)));
			this->UserInput->BorderStyle = System::Windows::Forms::BorderStyle::FixedSingle;
			this->UserInput->Cursor = System::Windows::Forms::Cursors::IBeam;
			this->UserInput->Font = (gcnew System::Drawing::Font(L"Consolas", 14.25F, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->UserInput->ForeColor = System::Drawing::Color::White;
			this->UserInput->Location = System::Drawing::Point(26, 155);
			this->UserInput->Margin = System::Windows::Forms::Padding(2);
			this->UserInput->Name = L"UserInput";
			this->UserInput->Size = System::Drawing::Size(687, 30);
			this->UserInput->TabIndex = 6;
			this->UserInput->TextChanged += gcnew System::EventHandler(this, &TaskkyGUI::UserInputTextBox_TextChanged_1);
			this->UserInput->KeyDown += gcnew System::Windows::Forms::KeyEventHandler(this, &TaskkyGUI::UserInputTextBox_KeyDown);
			this->UserInput->KeyPress += gcnew System::Windows::Forms::KeyPressEventHandler(this, &TaskkyGUI::UserInputTextBox_KeyPress);
			// 
			// TASKKYTitle
			// 
			this->TASKKYTitle->BackColor = System::Drawing::Color::Transparent;
			this->TASKKYTitle->Font = (gcnew System::Drawing::Font(L"Consolas", 39.75F, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->TASKKYTitle->ForeColor = System::Drawing::Color::WhiteSmoke;
			this->TASKKYTitle->Location = System::Drawing::Point(51, 7);
			this->TASKKYTitle->Name = L"TASKKYTitle";
			this->TASKKYTitle->Size = System::Drawing::Size(366, 58);
			this->TASKKYTitle->TabIndex = 14;
			this->TASKKYTitle->Text = L"T.A.S.K.K.Y";
			// 
			// CurrentTime
			// 
			this->CurrentTime->AutoSize = true;
			this->CurrentTime->BackColor = System::Drawing::Color::Transparent;
			this->CurrentTime->Font = (gcnew System::Drawing::Font(L"Calibri", 48, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->CurrentTime->ForeColor = System::Drawing::Color::Snow;
			this->CurrentTime->Location = System::Drawing::Point(130, 51);
			this->CurrentTime->Name = L"CurrentTime";
			this->CurrentTime->Size = System::Drawing::Size(178, 78);
			this->CurrentTime->TabIndex = 15;
			this->CurrentTime->Text = L"00:00";
			this->CurrentTime->TextChanged += gcnew System::EventHandler(this, &TaskkyGUI::timer1_Tick);
			// 
			// timer1
			// 
			this->timer1->Tick += gcnew System::EventHandler(this, &TaskkyGUI::timer1_Tick);
			// 
			// SuggestionText
			// 
			this->SuggestionText->AutoSize = true;
			this->SuggestionText->BackColor = System::Drawing::Color::Transparent;
			this->SuggestionText->Font = (gcnew System::Drawing::Font(L"Consolas", 9.75F, System::Drawing::FontStyle::Italic, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->SuggestionText->ForeColor = System::Drawing::Color::White;
			this->SuggestionText->Location = System::Drawing::Point(26, 187);
			this->SuggestionText->Name = L"SuggestionText";
			this->SuggestionText->Size = System::Drawing::Size(0, 15);
			this->SuggestionText->TabIndex = 16;
			// 
			// FeedbackUserInput
			// 
			this->FeedbackUserInput->AutoSize = true;
			this->FeedbackUserInput->BackColor = System::Drawing::Color::Transparent;
			this->FeedbackUserInput->ForeColor = System::Drawing::Color::White;
			this->FeedbackUserInput->Location = System::Drawing::Point(26, 140);
			this->FeedbackUserInput->Name = L"FeedbackUserInput";
			this->FeedbackUserInput->Size = System::Drawing::Size(0, 13);
			this->FeedbackUserInput->TabIndex = 18;
			// 
			// listView1
			// 
			this->listView1->BackColor = System::Drawing::Color::White;
			this->listView1->BorderStyle = System::Windows::Forms::BorderStyle::None;
			this->listView1->Columns->AddRange(gcnew cli::array< System::Windows::Forms::ColumnHeader^  >(4) {
				this->TaskNumber, this->StartTime,
					this->EndTime, this->TaskDetails
			});
			this->listView1->Font = (gcnew System::Drawing::Font(L"Calibri", 8.25F, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->listView1->ForeColor = System::Drawing::Color::Black;
			this->listView1->Location = System::Drawing::Point(29, 209);
			this->listView1->Name = L"listView1";
			this->listView1->Size = System::Drawing::Size(684, 335);
			this->listView1->TabIndex = 19;
			this->listView1->UseCompatibleStateImageBehavior = false;
			this->listView1->View = System::Windows::Forms::View::Details;
			// 
			// TaskNumber
			// 
			this->TaskNumber->Text = L"No";
			this->TaskNumber->Width = 33;
			// 
			// StartTime
			// 
			this->StartTime->Text = L"Start Time / Deadline";
			this->StartTime->Width = 182;
			// 
			// EndTime
			// 
			this->EndTime->Text = L"End Time";
			this->EndTime->Width = 173;
			// 
			// TaskDetails
			// 
			this->TaskDetails->Text = L"Task Details";
			this->TaskDetails->Width = 286;
			// 
			// UrgentTask
			// 
			this->UrgentTask->BackColor = System::Drawing::Color::Transparent;
			this->UrgentTask->FlatStyle = System::Windows::Forms::FlatStyle::Flat;
			this->UrgentTask->Font = (gcnew System::Drawing::Font(L"Calibri", 14.25F, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->UrgentTask->ForeColor = System::Drawing::Color::Red;
			this->UrgentTask->Location = System::Drawing::Point(518, 101);
			this->UrgentTask->Name = L"UrgentTask";
			this->UrgentTask->Size = System::Drawing::Size(148, 39);
			this->UrgentTask->TabIndex = 20;
			this->UrgentTask->Text = L"Urgent Task!";
			this->UrgentTask->TextAlign = System::Drawing::ContentAlignment::MiddleLeft;
			// 
			// NumberOfUrgentTask
			// 
			this->NumberOfUrgentTask->BackColor = System::Drawing::Color::Transparent;
			this->NumberOfUrgentTask->Font = (gcnew System::Drawing::Font(L"Calibri", 15.75F, System::Drawing::FontStyle::Underline, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->NumberOfUrgentTask->ForeColor = System::Drawing::Color::White;
			this->NumberOfUrgentTask->Location = System::Drawing::Point(492, 100);
			this->NumberOfUrgentTask->Name = L"NumberOfUrgentTask";
			this->NumberOfUrgentTask->Size = System::Drawing::Size(28, 39);
			this->NumberOfUrgentTask->TabIndex = 21;
			this->NumberOfUrgentTask->TextAlign = System::Drawing::ContentAlignment::MiddleCenter;
			// 
			// DueToday
			// 
			this->DueToday->BackColor = System::Drawing::Color::Transparent;
			this->DueToday->Font = (gcnew System::Drawing::Font(L"Calibri", 14.25F, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->DueToday->ForeColor = System::Drawing::Color::WhiteSmoke;
			this->DueToday->Location = System::Drawing::Point(518, 62);
			this->DueToday->Name = L"DueToday";
			this->DueToday->Size = System::Drawing::Size(148, 39);
			this->DueToday->TabIndex = 22;
			this->DueToday->Text = L"Due Today!";
			this->DueToday->TextAlign = System::Drawing::ContentAlignment::MiddleLeft;
			// 
			// NumberOfTaskDueToday
			// 
			this->NumberOfTaskDueToday->BackColor = System::Drawing::Color::Transparent;
			this->NumberOfTaskDueToday->Font = (gcnew System::Drawing::Font(L"Calibri", 18, System::Drawing::FontStyle::Underline, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->NumberOfTaskDueToday->ForeColor = System::Drawing::Color::WhiteSmoke;
			this->NumberOfTaskDueToday->Location = System::Drawing::Point(492, 61);
			this->NumberOfTaskDueToday->Name = L"NumberOfTaskDueToday";
			this->NumberOfTaskDueToday->Size = System::Drawing::Size(28, 39);
			this->NumberOfTaskDueToday->TabIndex = 23;
			this->NumberOfTaskDueToday->TextAlign = System::Drawing::ContentAlignment::MiddleCenter;
			// 
			// OverdueTask
			// 
			this->OverdueTask->BackColor = System::Drawing::Color::Transparent;
			this->OverdueTask->Font = (gcnew System::Drawing::Font(L"Calibri", 14.25F, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->OverdueTask->ForeColor = System::Drawing::Color::Gold;
			this->OverdueTask->Location = System::Drawing::Point(518, 23);
			this->OverdueTask->Name = L"OverdueTask";
			this->OverdueTask->Size = System::Drawing::Size(148, 39);
			this->OverdueTask->TabIndex = 24;
			this->OverdueTask->Text = L"Overdue Task";
			this->OverdueTask->TextAlign = System::Drawing::ContentAlignment::MiddleLeft;
			// 
			// NumberOfOverdueTask
			// 
			this->NumberOfOverdueTask->BackColor = System::Drawing::Color::Transparent;
			this->NumberOfOverdueTask->Font = (gcnew System::Drawing::Font(L"Calibri", 18, System::Drawing::FontStyle::Underline, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->NumberOfOverdueTask->ForeColor = System::Drawing::Color::WhiteSmoke;
			this->NumberOfOverdueTask->Location = System::Drawing::Point(492, 24);
			this->NumberOfOverdueTask->Name = L"NumberOfOverdueTask";
			this->NumberOfOverdueTask->Size = System::Drawing::Size(28, 39);
			this->NumberOfOverdueTask->TabIndex = 25;
			this->NumberOfOverdueTask->TextAlign = System::Drawing::ContentAlignment::MiddleCenter;
			// 
			// HelpButton
			// 
			this->HelpButton->AutoSize = true;
			this->HelpButton->BackColor = System::Drawing::Color::Transparent;
			this->HelpButton->Font = (gcnew System::Drawing::Font(L"Calibri", 9, System::Drawing::FontStyle::Bold, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->HelpButton->ForeColor = System::Drawing::Color::WhiteSmoke;
			this->HelpButton->Location = System::Drawing::Point(622, 551);
			this->HelpButton->Name = L"HelpButton";
			this->HelpButton->Size = System::Drawing::Size(93, 14);
			this->HelpButton->TabIndex = 26;
			this->HelpButton->Text = L"Press F1 For Help";
			// 
			// TaskkyGUI
			// 
			this->AutoScaleDimensions = System::Drawing::SizeF(6, 13);
			this->AutoScaleMode = System::Windows::Forms::AutoScaleMode::Font;
			this->AutoSize = true;
			this->BackgroundImage = (cli::safe_cast<System::Drawing::Image^>(resources->GetObject(L"$this.BackgroundImage")));
			this->BackgroundImageLayout = System::Windows::Forms::ImageLayout::Stretch;
			this->ClientSize = System::Drawing::Size(735, 575);
			this->Controls->Add(this->HelpButton);
			this->Controls->Add(this->TASKKYTitle);
			this->Controls->Add(this->FeedbackUserInput);
			this->Controls->Add(this->NumberOfOverdueTask);
			this->Controls->Add(this->OverdueTask);
			this->Controls->Add(this->NumberOfTaskDueToday);
			this->Controls->Add(this->DueToday);
			this->Controls->Add(this->NumberOfUrgentTask);
			this->Controls->Add(this->UrgentTask);
			this->Controls->Add(this->listView1);
			this->Controls->Add(this->SuggestionText);
			this->Controls->Add(this->CurrentTime);
			this->Controls->Add(this->UserInput);
			this->DoubleBuffered = true;
			this->Font = (gcnew System::Drawing::Font(L"Calibri", 8.25F, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->FormBorderStyle = System::Windows::Forms::FormBorderStyle::None;
			this->Name = L"TaskkyGUI";
			this->StartPosition = System::Windows::Forms::FormStartPosition::CenterScreen;
			this->Text = L"TaskkyGUI";
			this->Load += gcnew System::EventHandler(this, &TaskkyGUI::timer1_Tick);
			this->ResumeLayout(false);
			this->PerformLayout();

		}
#pragma endregion
	private: System::Void TaskkyGUIContent_Load(System::Object^  sender, System::EventArgs^  e) {
	}

	public: System::Windows::Forms::ListViewItem^ addNewItem(int taskNumber,
		string startDate, string endDate, string taskDetails, int taskPriority,
		bool taskMarked) {

		ListViewItem^ newItem;

		//adding first item of the row
		newItem = gcnew ListViewItem(Convert::ToString(taskNumber));

		//adding second, third and forth item of the row
		newItem->SubItems->Add(gcnew String(startDate.c_str()));
		newItem->SubItems->Add(gcnew String(endDate.c_str()));
		newItem->SubItems->Add(gcnew String(taskDetails.c_str()));
		newItem->SubItems->Add(Convert::ToString(taskPriority));

		if (taskMarked){

			newItem->ForeColor = Color::DarkGray;
		}

		else{

			if (taskPriority == Task::HIGH){

				newItem->ForeColor = Color::Red;

			}

		}

		return newItem;
	}




	public: System::Void UserInputTextBox_KeyPress(System::Object^  sender, System::Windows::Forms::KeyPressEventArgs^  e) {

		//When Enter is pressed

		if (e->KeyChar == (char)13){

			//get data from the textbox

			Controller* controllerInstance = Controller::getInstance();

			result = controllerInstance->processUserInput(command);

			FeedbackUserInput->Text = gcnew String(result.c_str());

			if (command == "display"){

				FeedbackUserInput->Text = "";

			}

			
			listView1->Items->Clear();


			if (controllerInstance->getIsSearchCommand()){

				vector<int>* taskIndices = controllerInstance->getTaskIndices();

				vector<Task>* allCurrentTasks = TaskManager::getAllCurrentTasks();

				for (int i = 0; i != taskIndices->size(); i++){

					int index = (*taskIndices)[i];

					Task task = (*allCurrentTasks)[index - 1];

					ListViewItem^ newEntry;

					if (task.getTaskType() == Task::FLOATING){

						ListViewItem^ newEntry = addNewItem(index, "--------",
							"--------", task.getTaskDetails(),
							task.getTaskPriority(), task.getTaskMarked());

						array<ListViewItem^>^FloatingTasks = { newEntry };
						listView1->Items->AddRange(FloatingTasks);

					}

					else if (task.getTaskType() == Task::DEADLINE){
						ListViewItem^ newEntry = addNewItem(index,
							task.getTaskDeadline()->toString(),
							"--------", task.getTaskDetails(),
							task.getTaskPriority(), task.getTaskMarked());

						array<ListViewItem^>^DeadlineTasks = { newEntry };
						listView1->Items->AddRange(DeadlineTasks);

					}

					else{

						ListViewItem^ newEntry = addNewItem(index,
							task.getTaskStartTime()->toString(),
							task.getTaskEndTime()->toString(),
							task.getTaskDetails(), task.getTaskPriority(),
							task.getTaskMarked());

						array<ListViewItem^>^TimedTasks = { newEntry };
						listView1->Items->AddRange(TimedTasks);
					}
				}
				UserInput->Clear();
			}

			else{

				TaskManager *taskManager = TaskManager::getInstance();
				int taskNumber = 0;
				int taskUrgent = 0;
				int taskDueToday = 0;
				int taskOverdue = 0;

				//adding all current timed tasks

				vector<Task> *allTimedTasks;
				allTimedTasks = taskManager->getAllTimedTasks();

				for (int i = 0; i != allTimedTasks->size(); i++){

					Task task = (*allTimedTasks)[i];

					if (task.getTaskType() == Task::TIMED)

					{
						if (task.getTaskPriority() == Task::HIGH){
							taskUrgent += 1;
						}

						//setting new parameters to add next task

						taskNumber += 1;
						string startDate = task.getTaskStartTime()->toString();
						string endDate = task.getTaskEndTime()->toString();
						string taskDetails = task.getTaskDetails();
						int taskPriority = task.getTaskPriority();
						bool markedTask = {};

						ListViewItem^ newEntry = addNewItem(taskNumber,
							startDate, endDate, taskDetails, taskPriority, markedTask);

						array<ListViewItem^>^TimedTasks = { newEntry };
						listView1->Items->AddRange(TimedTasks);
					}


					if (task.getTaskType() == Task::DEADLINE)

					{
						if (task.getTaskPriority() == Task::HIGH){
							taskUrgent += 1;
						}

						//setting new parameters to add next task

						taskNumber += 1;
						string startDate = task.getTaskDeadline()->toString();
						string endDate = "----------";
						string taskDetails = task.getTaskDetails();
						int taskPriority = task.getTaskPriority();
						bool markedTask = {};

						if (task.getTaskDeadline()->sameDate(Date::Date())){

							taskDueToday += 1;
						}

						if ((Date::Date()).isEarlierThan(*task.getTaskDeadline())<0){

							taskOverdue += 1;
						}

						//}

						ListViewItem^ newEntry = addNewItem(taskNumber,
							startDate, endDate, taskDetails, taskPriority, markedTask);


						array<ListViewItem^>^TimedTaskswithDeadline = { newEntry };
						listView1->Items->AddRange(TimedTaskswithDeadline);

						if ((Date::Date()).isEarlierThan(*task.getTaskDeadline())<0){

							newEntry->ForeColor = Color::DarkGoldenrod;
						}
					}


				}

				//adding all current floating tasks

				vector<Task> *allFloatingTasks;
				allFloatingTasks = taskManager->getAllFloatingTasks();

				for (int i = 0; i != allFloatingTasks->size(); i++){
					Task task = (*allFloatingTasks)[i];

					if (task.getTaskPriority() == Task::HIGH){
						taskUrgent += 1;
					}


					//setting new parameters to add next task

					taskNumber += 1;
					string startDate = "----------";
					string endDate = "----------";
					string taskDetails = task.getTaskDetails();
					int taskPriority = task.getTaskPriority();
					bool markedTask = {};


					ListViewItem^ newEntry = addNewItem(taskNumber,
						startDate, endDate, taskDetails, taskPriority, markedTask);

					array<ListViewItem^>^FloatingTasks = { newEntry };
					listView1->Items->AddRange(FloatingTasks);

				}

				//adding all marked timed task
				vector<Task> *allMarkedTimedTask;
				allMarkedTimedTask = taskManager->getAllMarkedTimedTasks();


				for (int i = 0; i != allMarkedTimedTask->size(); i++){
					Task task = (*allMarkedTimedTask)[i];

					//set type

					if (task.getTaskType() == Task::TIMED){

						//setting new parameters to add next task

						taskNumber += 1;
						string startDate = task.getTaskStartTime()->toString();
						string endDate = task.getTaskEndTime()->toString();
						string taskDetails = task.getTaskDetails();
						int TaskPriority;
						bool markedTask = 1;


						ListViewItem^ newEntry = addNewItem(taskNumber,
							startDate, endDate, taskDetails, TaskPriority, markedTask);


						array<ListViewItem^>^MarkedTimedTasks = { newEntry };
						listView1->Items->AddRange(MarkedTimedTasks);
					}

					if (task.getTaskType() == Task::DEADLINE){

						//setting new parameters to add next task
						taskNumber += 1;
						string startDate = task.getTaskDeadline()->toString();
						string endDate = "";
						string taskDetails = task.getTaskDetails();
						int TaskPriority;
						bool markedTask = 1;


						ListViewItem^ newEntry = addNewItem(taskNumber,
							startDate, endDate, taskDetails, TaskPriority, markedTask);


						array<ListViewItem^>^MarkedTimedTasksWithDeadline = { newEntry };
						listView1->Items->AddRange(MarkedTimedTasksWithDeadline);

					}

				}

				//adding all marked floating task

				vector<Task> *allMarkedFloatingTask;
				allMarkedFloatingTask = taskManager->getAllMarkedFloatingTasks();


				for (int i = 0; i != allMarkedFloatingTask->size(); i++){

					//setting new parameters to add next task
					Task task = (*allMarkedFloatingTask)[i];
					taskNumber += 1;
					string startDate = "";
					string endDate = "";
					string taskDetails = task.getTaskDetails();
					int TaskPriority;
					bool markedTask = 1;


					ListViewItem^ newEntry = addNewItem(taskNumber,
						startDate, endDate, taskDetails, TaskPriority, markedTask);


					array<ListViewItem^>^MarkedFloatingTasks = { newEntry };
					listView1->Items->AddRange(MarkedFloatingTasks);

				}

				NumberOfUrgentTask->Text = Convert::ToString(taskUrgent);
				NumberOfTaskDueToday->Text = Convert::ToString(taskDueToday);
				NumberOfOverdueTask->Text = Convert::ToString(taskOverdue);

				UserInput->Clear();

			}

		}
		SuggestionText->Text = "e.g: add, delete, update, search, mark, unmark, undo, checkfilelocation, changefilelocation";
		SuggestionText->Text = gcnew String(SuggestionBuilder::suggestUserInput(command).c_str());

	}

	private: System::Void richTextBox1_TextChanged(System::Object^  sender, System::EventArgs^  e) {
	}
	private: System::Void UserInputTextBox_TextChanged_1(System::Object^  sender, System::EventArgs^  e) {
		command = msclr::interop::marshal_as< std::string >(UserInput->Text);
	}
	private: System::Void label2_Click(System::Object^  sender, System::EventArgs^  e) {
	}

	private: System::Void checkBox1_CheckedChanged(System::Object^  sender, System::EventArgs^  e) {
	}
	private: System::Void richTextBox1_TextChanged_1(System::Object^  sender, System::EventArgs^  e) {
	}
	private: System::Void label1_Click_1(System::Object^  sender, System::EventArgs^  e) {
	}
	private: System::Void textBox2_TextChanged(System::Object^  sender, System::EventArgs^  e) {

	}
	public: System::Void timer1_Tick(System::Object^  sender, System::EventArgs^  e) {



		int hh = Date().getHour();
		int mm = Date().getMinute();

		//time

		System::String^ time = "";

		//Padding leading zero
		if (hh < 10)
		{
			time += "0" + hh;
		}
		else
		{
			time += hh;
		}
		time += ":";

		if (mm < 10)
		{
			time += "0" + mm;
		}
		else
		{
			time += mm;
		}

		CurrentTime->Text = time;


	}

	private: System::Void UserInputTextBox_KeyDown(System::Object^  sender, System::Windows::Forms::KeyEventArgs^  e) {
		if (e->KeyCode == Keys::PageDown){
			listView1->Focus();
			SendKeys::SendWait("{PGDN}");
			UserInput->Focus();
		}
		else if (e->KeyCode == Keys::PageUp){
			listView1->Focus();
			SendKeys::SendWait("{PGUP}");
			UserInput->Focus();
		}

		if (e->KeyCode == Keys::F1){
			ShellExecuteA(NULL, "open", "..\\help.pdf", NULL, NULL, 0);
		}
	}
	};
}

	// End of segment: C:\Users\Adi!\Desktop\CS2103\Taskky\TaskkyUI\TaskkyGUI.h





